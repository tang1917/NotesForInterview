# 零拷贝

主要任务是避免CPU将数据从一块存储拷贝到另一块存储， **内核缓冲区和用户缓冲区之间的的数据拷贝，称为零拷贝**

## DMA（直接存储器访问）

指外部设备不通过CPU而直接而直接与系统内存交换数据的接口技术

## 将服务器端主机磁盘文件中的文件不做修改地从已连接的文件中发送出去

1. 将磁盘上的数据拷贝到内核缓冲区（主要依靠DMA来实现）
2. 再把内核缓冲区的内容拷贝到用户缓冲区
3. 用户缓冲区的内容拷贝到socket缓冲区
4. socket缓冲区的内容发送到网卡

## mmap()函数

应用程序调用mmap()，磁盘上的数据通过DMA拷贝到内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区，这一切都发生在内核态。

## 可能出现的问题

**当程序mmap了一个文件，但是当这个文件被另一个进程截断时，write系统调用会因为访问非法地址而被SIGBUS信号终止。**

sendfile()

splice（）

# 用户缓冲区、内核缓冲区

## 用户缓冲区

* 一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffe
* 作用：`减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间`。

## 内核缓冲区

当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务

等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程

* **read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。**

## socket缓冲区

* 当某个应用进程调用套接字的write方法时，会先将数据写入该应用进程的缓冲区，此后内核会从该应用进程的缓冲区复制所有数据到要写的套接字的发送缓冲区

* 如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据）， 该应用进程则无法继续写入自身的缓冲区，此时将会被阻塞住。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区
* 如果调用TCP套接字的write方法并成功返回时，仅仅能代表我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据，数据可能还在TCP的发送缓冲区中



# socket可读可写情况

* 可读
  * 内核接收缓冲区中的字节数大于或等于其低水位标记
  * socket通信的对方关闭连接，此时对该socket的读操作将返回0
  * 监听socket上有新的连接请求
  * socket上有未处理的错误
* 可写
  * 发送缓存区可用字节数大于或等于其低水位标记
  * socket的写操作被关闭
  * socket使用非阻塞connect连接成功或者失败（超时）之后
  * socket上有未处理的错误

# ps命令

-A:列出所有的进程

-aux:显示所有包含其他使用者的进程

r:显示当前终端的进程

USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND

-f 进程之间的关系

# TOP命令

**提供实时的系统处理器的状态监**视，它是一个动态的显示过程

* 第一行显示内容：

当前时间，系统运行时间，当前登录用户数，系统负载

* 第二行显示内容

进程总数，正在运行数，睡眠的进程数，停止的进程数，僵尸进程数

* 第三行

用户空间占用cpu百分比，内核空间占用cpu百分比，用户进程空间内改变过优先级的进程占用cpu百分比，空闲cpu占用百分比

* 第四、五行

物理内存总量，使用的物理内存总量，空闲内存总量，用作内核缓存的内存量

* 进程信息

进程id，进程所有者的用户名，

# linux进程有几种状态，如何查看

ps top

