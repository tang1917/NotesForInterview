


# 一、事务

## 概念

事务指的是一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行，也就是要满足：原子性，一致性，隔离性，持久性（ACID）

## 四大特性

### 1. 原子性（Atomicity）

事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。

### 2. 一致性（Consistency）

**这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.当前的状态满足预定的约束就叫做正确的状态.**

### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 4. 持久性（Durability）

**一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。**

# 二、并发一致性问题

在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。

## 问题

### 1. 丢失修改

T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

### 2. 读脏数据

指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的

### 3. 不可重复读

指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。

### 4. 幻影读

T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 解决方法

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

在没有并发的情况下，事务以串行的方式执行，互不干扰，因此可以保证隔离性。在并发的情况下，如果能通过并发控制，让事务的执行结果和某一个串行执行的结果相同，就认为事务的执行结果满足隔离性要求，也就是说是正确的。把这种事务执行方式称为  **可串行化调度** 。

**并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。** 

# 三、封锁

## 封锁粒度

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查锁是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。需要在锁开销以及数据安全性之间做一个权衡。

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

## 封锁类型

### 1. 排它锁与共享锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

1. 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
2. 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

| - | X | S |
| :--: | :--: | :--: |
|X|No|No|
|S|No|Yes|

### 2. 意向锁

意向锁（Intention Locks）可以支持多粒度封锁。它本身是一个表锁，通过在原来的 X/S 锁之上引入了 IX/IS，用来表示一个事务想要在某个数据行上加 X 锁或 S 锁。

有以下两个规定：

1. 一个事务在获得某个数据行对象的 S 锁之前，必须先获得 IS 锁或者更强的锁；
2. 一个事务在获得某个数据行对象的 X 锁之前，必须先获得 IX 锁。

各种锁的兼容关系如下：

| - | X | IX | S | IS |
| :--: | :--: | :--: | :--: | :--: |
|X    |No    |No |No | No|
|IX    |No    |Yes|No | Yes|
|S    |No    |No    |Yes| Yes|
|IS    |No    |Yes|Yes| Yes|

## 封锁协议

### 1. 三级封锁协议

**一级封锁协议** 

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么一个事务的修改就不会被覆盖。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-x(A) | |
| read A=20 | |
| | lock-x(A) |
|  | wait |
| write A=19 | |
| commit | |
| unlock-x(A) | |
| | obtain |
| | read A=19 |
| | write A=21 |
| | commit |
| | unlock-x(A)|

**二级封锁协议** 

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-x(A) | |
| read A=20 | |
| write A=19 | |
| | lock-s(A) |
|  | wait |
| rollback | |
| A=20 | |
| unlock-x(A) | |
| | obtain |
| | read A=20 |
| | commit |
| | unlock-s(A)|

**三级封锁协议** 

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-s(A) | |
| read A=20 | |
|  |lock-x(A) |
| | wait |
|  read A=20|  |
| commit | |
| unlock-s(A) | |
| | obtain |
| | read A=20 |
| | write A=19|
| | commit |
| | unlock-X(A)|

### 2. 两段锁协议

加锁和解锁分为两个阶段进行，事务 T 对数据 A 进行读或者写操作之前，必须先获得对 A 的封锁，并且在释放一个封锁之后，T 不能再获得任何的其它锁。

事务遵循两段锁**协议是保证并发操作可串行化调度的充分条件**。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(c)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(c)...unlock(C)...
```

# 四、隔离级别

<font size=4>  **1. 读未提交（READ UNCOMMITTED）** </font> </br>

事务中的修改，即使没有提交，对其它事务也是可见的。

<font size=4>  **2. 读已提交（READ COMMITTED）** </font> </br>

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

<font size=4>  **3. 可重复读（REPEATABLE READ）** </font> </br>

保证在同一个事务中多次读取同样数据的结果是一样的。

<font size=4>  **4. 可串行化（SERIALIXABLE）** </font> </br>

强制事务串行执行。

<font size=4>  **四个隔离级别的对比** </font> </br>

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| :---: | :---: | :---:| :---: |
| 未提交读 | YES | YES | YES |
| 提交读 | NO | YES | YES |
| 可重复读 | NO | NO | YES |
| 可串行化 | NO | NO | NO |

# 五、多版本并发控制

（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。mvcc主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，读操作只读该事务开始前的数据库的快照，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

## 实现过程

InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照
连接起来。  

InnoDB是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时的系统版本号，一个保存了行删除时的系统版本号。每开始一个新事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和每行查询到的事务比较。在可重复读级别下

**当执行查询操作时：**

InnoDB只查找早于当前事务版本的数据行，也就是说行的系统版本号小于或等于事务的版本号，这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务本身插入或修改过的。

同时行的删除版本要么没定义，要么大于当前事务版本号。这可以确保读取到的行，在事务开始之前未被删除。

**当执行插入操作时：**

InnoDB为新插入的每一行保存当前系统版本号作为行版本号

**当执行删除操作时**

为删除的每一行保存当前系统版本号作为行删除标识

**当执行更新操作时**

插入一条行新记录，保存当前系统版本号作为行版本号，同时保存当前版本号为原来行的删除标识。

## 读已提交和可重复读的实现方式

* **读已提交**：每次进行检索之前都创建新的快照
* **可重复读**：第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用这个read_view。所以能保证每次读取的一致性，即都是读取第一次读取到的内容（可重复读的语义）

## 快照读与当前读

### 1. 快照读

快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

引入快照读的目的主要是为了免去加锁操作带来的性能开销，但是当前读需要加锁。

```sql
select * from table ....;
```

### 2. 当前读

它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update ;
delete;
```

# 六、Next-Key Locks

Next-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，MVCC + Next-Key Locks，就可以防止幻读的出现。

## Record Locks

锁定的对象是索引，而不是数据。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。

## Grap Locks

锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合。在 user 中有以下记录：

```sql
|   id | last_name   | first_name   |   age |
|------|-------------|--------------|-------|
|    4 | stark       | tony         |    21 |
|    1 | tom         | hiddleston   |    30 |
|    3 | morgan      | freeman      |    40 |
|    5 | jeff        | dean         |    50 |
|    2 | donald      | trump        |    80 |
+------|-------------|--------------|-------+
```

那么就需要锁定以下范围：

```sql
(-∞, 21]
(21, 30]
(30, 40]
(40, 50]
(50, 80]
(80, ∞)
```

# 七、关系数据库设计理论

## 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 W->A，如果能找到 W 的真子集 W'，使得 W'-> A，那么 W->A 就是部分函数依赖，否则就是完全函数依赖；

## 异常

不符合范式的关系，会产生很多异常，主要有以下四种异常：

1. 冗余数据，例如学生-2 出现了两次。
2. 修改异常，修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
3. 删除异常，删除一个信息，那么也会丢失其它信息。例如如果删除了课程-1，需要删除第二行和第三行，那么学生-1 的信息就会丢失。
4. 插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

## 范式

为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

### 1. 第一范式 (1NF)

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式

### 2. 第二范式 (2NF)

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中每个非主属性对于码都是完全函数依赖不是部分函数依赖。

**学号 姓名 系名 系主任 课名 分数** 不符合第二范式

原因：

​	**学号和课名是主属性**

​	**系名只依赖学号不依赖课名**

### 3. 第三范式 (3NF)（确保非主键的列没有传递依赖）

第三范式消除了非主属性对于码的传递函数依赖。

**学号 姓名 系名 系主任** 不符合第三范式



## 4.  BC 范式（BCNF）

主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。

# MYSQL 存储引擎

* **概念：**数据库存储引擎是**数据库底层软件组件**，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。
* 种类
  1. InnoDB

      * InnoDB是MySQL默认的事务性存储引擎，只有在需要InnoDB不支持的特性时，才考虑使用其他存储引擎。实现了四个标准的隔离级别，读未提交，读提交，可重复读，可串行化，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制（MVCC）+间隙锁防止幻影读。

  2. MyISAM

      * MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小，可以容忍修复操作，则依然可以使用MyISAM。

  3. MEMORY

      memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景
* 区别

  1. InnoDB支持事务，MyISAM不支持。
  2. InnoDB支持外键，而MyISAM不支持，对一个包含外键的 InnoDB 表转为 MYISAM 会失败
  3. MyISAM的支持三种不同的存储格式：静态表、动态表、压缩表。当使用压缩表时，能极大减少磁盘空间的占用，同时保存成表格式，跨平台使用方便；InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
  4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
  5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
  6. InnoDB表必须有主键(用户没有指定的话会自己找或生产一个主键)，而Myisam可以没有

* 解释

  1. 主键：唯一标识表中每行的这个列（或这组列）成为主键

  2. 外键：如果一个字段X在一张表（表一）中是主关键字，而在另外一张表（表二）中不是主关键字，则字段X称为表二的外键；换句话说如果关系模式R1中的某属性集不是自己的主键，而是关系模式R2的主键，则该属性集称为是关系模式R1的外键

  3. 索引

     索引是关系型数据库中给数据库表中**一列或多列的值排序后的存储结构**，相当于数据库的目录，通过索引能够优化查询速度。SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。

  4. 聚集索引

     数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引，聚集索引时叶结点存储的是数据

  5. 非聚集索引

     该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。，非聚集索引叶结点存储的是指向数据的指针，**查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据**。

  6. 聚集索引与非聚集索引的使用

     1. 使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
     2. 非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升

# innoDB索引的4大特性

1. 插入缓冲

   首先判断要插入的索引页是否已经存在内存中了，如果不在，暂时不着急把索引页插入到内存中，而是放到一个Insert Buffer对象中，等待很多和现在情况一样的非聚集索引，再和要插入的索引合并，减少插入的次数提升性能。

2. 双写机制

   解决当数据库正在从内存中向磁盘写一个数据页时，数据库宕机导致这个页只写了部分数据，这就是部分写失效，无法通过重做日志恢复。

   1. 当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝到内存中的两次写缓冲区。
   2. 接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB
   3. 待第二部完成后，再将两次写缓存区中的数据写入数据文件。

3. 自适应哈希索引

   InnoDB存储引擎会监控对表上辅助索引页的查询，如果观察到建立hash索引可以提升性能，就会在缓冲池中建立hash索引，称之为自适应哈希索引。

4. 预读

   预读操作是一种IO操作，用于异步将磁盘的页读取到buffer pool中，预料这些页马上会被读取到。

# mysql执行一条查询语句的内部执行过程

1. 连接器：客户端先通过连接器连接到Mysql服务器
2. 缓存：连接器权限验证通过后，先查询是否有查询缓存，如果有缓存，则直接返回缓存数据，如果没有缓存数据则进入分析器
3. 分析器：分析器会对查询语句进行语法分析和词法分析，判断SQL语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器
4. 优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好
5. 执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询对比了，直到查询到满足条件的所有数据，然后返回。

# 索引

索引是关系型数据库中给数据库表中**一列或多列的值排序后的存储结构**，相当于数据库的目录，通过索引能够优化查询速度。B+树是最常用的用于索引的数据结构。

notes：**数据库索引并不存储这个表中其他列（字段）的值**，索引存储了指向表中某一行的指针

## 数据库的索引类型

数据库的索引类型分为逻辑分类和物理分类

1. **逻辑分类**

   * 主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。
   * 唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。
   * 普通索引 一张表可以有多个普通索引，可以重复可以为空值
   * 全文索引 可以加快模糊查询，不常用

2. **物理分类**

   1. 聚集索引

      叶结点存储的是数据，数据行的物理顺序与用做索引的列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

   2.非聚集索引

   ​	该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。非聚集索引叶结点存储的是指向 数据的指针，**查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据**。

3. **数据结构**

   哈希索引

   B+树

## 哈希索引

哈希索引在寻找值时哈希表效率极高。哈希表是无序的数据结构，对于很多类型的查询语句哈希索引都无能为力

# 索引的优点

* 大大减少了服务器需要扫描的行数
* 帮助服务器避免排表和创建临时表（B+数是有序的）
* 将随机I/O变为顺序I/O(b+树索引是有序的，也就将相邻的数据都存储在一起)

# 索引的缺点

* 创建索引和维护索引要耗费时间，这种时间随数据量的增加而增加
* 索引需要占据物理空间

# 创建索引的原则

1. 选择唯一性索引
2. 为经常需要排序、分组和联合操作的字段建立索引
3. 为常作为查询条件的字段建立索引
4. 限制索引的数目，索引越多占用的磁盘空间越大
5. 尽量使用前缀索引

# 索引优化

1. 独立的列

   在进行查询时，索引列不是表达式的一部分，也不能是函数的参数，否则无法使用索引

2. 多列索引

   在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好

3. 索引列顺序

   让选择性较强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值

4. 前缀索引

   对于BLOB、TEXT、和VARCHAR类型的列，必须使用前缀索引，只索引开始部分的字符

5. 覆盖索引

   索引包含所有需要查询的字段的值

# 创建删除索引的方式

* ALTER TABLE table_name ADD INDEX index_name(column_list)
* ALTER TABLE table_name drop index_name

# 创建索引一定能提高查询性能吗

不一定，当数据库中数据比较少时没必要建立索引

# 百万级别或以上的数据如何删除

因为索引文件是单独存在的文件，所以当对数据进行增加删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的IO，会降低操作的效率。所以在我们删除百万级别的数据时可以：

1. 删除索引
2. 删除其中无用的元素
3. 重建索引

# 前缀索引

基于原始索引字段，截取前面指定的字符个数或者字节数建立索引。

# 最左匹配原则

MySQL建立联合索引时会遵循最左前缀匹配原则，即最左优先。

# 联合索引的好处

* 减少开销，建立一个（c1,c2,c3）,相当于建立了（c1）（c1,c2）,(c1,c2,c3)三个索引
* 覆盖索引
* 效率高，索引列越多，通过索引筛选出的数据越少。

# 查询优化

使用Explain进行优化

## 优化数据访问

1. 减少请求的数据量
    * 只返回必要的列
      	* 最好不要使用SELECT *
   * 只返回必要的行
     * 使用where语句进行查询过滤，有时候也需要使用LIMIT语句来限制返回的数据
   * 缓存重复查询的数据
     * 使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的
2. 减少服务器端扫描的行数
   * 最有效的方式是使用索引来覆盖查询

# 重构查询方式

1. 切分大查询

   一个大查询如果一次性执行的话，可能会锁住很多数据，占满整个事务日志、耗尽系统资源，阻塞很多小的但重要的查询

2. 分解大连接查询

   将一个大连接查询分解成堆每一个表进行一次单表查询，然后将结果在应用程序中关联，这样做的好处有：

   * 让缓存更高校。对于连接查询，如果一个表发生变化，那么整个查询缓存就无法使用。而分解为多个查询，即使一个表发生了变化，对其他表的查询缓存依然可以使用。
   * 分解成多个单表查询，这些单表查询的缓存结果更可能被其他查询使用，从而减少冗余记录的查询
   * 减少锁竞争
   * 在应用层进行连接可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展

## 切分

1. 水平切分

他是将同一个表中的记录拆分到多个结构相同的表中，将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

2. 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中

## 复制

主从复制，读写分离：

主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作

提高性能原因：

	* 主从服务器各自负责读写极大的缓解了锁的征用
	* 增加冗余，提高可用性

# 事务是怎么实现的

事务指的是一个或一组sql语句组成一个执行单元，这个执行单元构成一个上的整体，要么全部执行，要么全部不执行，具有原子性，一致性，隔离性，持久性（ACID）的特点，实现事物就是要保证可靠性和并发性，而这些是靠日志恢复和并发控制实现的。

* 日志恢复：

  数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的**持久性**。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证未提交事务的**原子性**。

* 并发控制：

* 并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的**隔离性**。MVCC通过为数据添加时间戳来实现

# 数据的锁的种类，加锁方式

* 按照类型来分有乐观锁和悲观锁
* 按照粒度来分有行级锁，页级锁，表级锁
* 按照作用来分有共享锁和排他锁

# 什么是共享锁和排他锁

* 共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。
* 排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）

# 分库分表的理解和简介

* 分表

  单表数据量太大，会极大影响你的 sql 执行的性能，到了后面 sql 可能就跑的很慢了。就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。

* 分库

一个库的数据拆分到多个库中，访问的时候就访问一个库好了。更好的适应高并发问题

# 分库分表中间件

TDDL，mycat

# 数据库水平拆分或垂直拆分

* 水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。

* 垂直拆分

把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。

# 数据库高并发的解决方案

1. 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担
2. 增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）
3. 主从读写分离，让主服务器负责写，从服务器负责读。
4. 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度
5. 使用分布式架构，分散计算压力

# 乐观锁和悲观锁

一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。

悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。

# 乐观锁和悲观锁怎么实现的

* 悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。

* 乐观锁有三种常用的实现形式
  1. 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决
  2. 一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。
  3. 最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似

# 死锁，如何解决

1. 死锁在操作系统中指两个或两个以上进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

## 原因

1. 事物之间对资源访问顺序的交替

   1. 用户a访问表(a)锁住了表A，然后又访问表B,用户b访问了表b锁住了表B，然后又访问表A。

2. 并发修改统一记录

   主要是一次没有申请够权限所致。

   A查询一条记录，然后修改该记录；这时B修改该记录，这时A事务企图由查询的共享锁上升到独占锁，而B独占锁在等待A释放共享锁，由于B独占锁的存A也无法上升为独占锁。

## 解决方法

* 现写写并发

* 悲观锁进行控制

* 对数据库进行多表操作时，尽量按相同的顺序去访问表

## 避免死锁

* 以固定的顺序访问表和行
* 同一个事务中。尽可能一次锁定所需要的所有资源
* 降低隔离级别
* 为表添加合理的索引，如果不走索引将会为表的每一行添加上锁，死锁概率增加。



# 数据库优化

## 索引优化

* 独立的列
  * 在进行查询时，索引列不能是表达式的一部分也不能是函数的参数

* 多列索引
  * 在需要使用多个列作为条件进行查询时使用多列索引比使用多个单列索引性能更好
* 索引列的顺序
  * 在选择性较强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。
* 前缀索引
  * 对于BLOB、TXT和VARCHAR类型的列，必须使用前缀索引，之索引开始部分的字符。
* 覆盖索引
  * 索引包含所有需要查询的字段的值

# MySQL锁机制

## 锁粒度

* 行级索，并发度最高
* 表级锁
* 页面锁

## 锁类型

* 读锁，写锁，间隙锁

## 锁协议

* 三级锁协议
* 二段锁协议

# MYSQL特性

* 锁机制
* 事务特性
* 存储引擎
* 隔离级别



# 数据类型

## 字符串数据类型

* CHAR
* TEXT
* VARCHAR

## 数值数据类型

* BIT
* INT 
* FLOAT

## 日期和时间数据类型

* DATE
* TIME
* DATETIME

## 二进制数据类型

* BLOB
* LONGBLOB

# 视图

## 什么是视图

视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。

## 为什么使用视图

* 重用SQL语句
* 简化复杂的SQL操作，在编写查询后可以方便的重用它而不必知道它的基本查询细节。
* 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限
* 更该数据格式和表示。视图可返回与底层表的表示和格式不同的数据。

## 缺点

视图不包含数据，每次使用视图都必须处理查询执行时所需要的任一检索。如果使用了多个连接或顾虑创建了复杂的视图，可能会发现性能下降的厉害。

# 存储过程

## 概念

为以后的使用而保存的一条或多条MySQL语句集合

## 为什么要使用存储过程

* 把处理封装在容易使用的单元中，简化复杂的操作
* 由于不需要反复建立一系列处理操作，这保证了数据的完整性
* 简化对变动的管理
* 提高性能

## 创建存储过程

CREADTE PROCEDURE productpricing(参数) 参数表示：OUT IN INTO

## 删除

DROP PROCEDURE productpricing

# 使用游标

## 概念

在存储了游标后，应用程序可以根据需要滚动或浏览其中的数据

## 声明

* DECLARE name CURSOR FOR SQL语句
* FETCH name INTO 变量
* OPEN name
* CLOSE name 

# 触发器

## 概念

MySQL响应INSERT,DELETE,UPDATE任意语句时自动执行的一条MySQL语句

## 使用

CREATE TRIGGER newproduct AFTER INSERT ON products

FOR EACH ROW SELECT 执行语句；

