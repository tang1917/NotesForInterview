


# 一、事务

## 概念

事务指的是一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行，也就是要满足：原子性，一致性，隔离性，持久性（ACID）

## 四大特性

### 1. 原子性（Atomicity）

事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。

### 2. 一致性（Consistency）

**这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.当前的状态满足预定的约束就叫做正确的状态.**

### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。

# 二、并发一致性问题

在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。

## 问题

### 1. 丢失修改

T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

### 2. 读脏数据

指当一个事务正在访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的

### 3. 不可重复读

指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。

### 4. 幻影读

T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 解决方法

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

在没有并发的情况下，事务以串行的方式执行，互不干扰，因此可以保证隔离性。在并发的情况下，如果能通过并发控制，让事务的执行结果和某一个串行执行的结果相同，就认为事务的执行结果满足隔离性要求，也就是说是正确的。把这种事务执行方式称为  **可串行化调度** 。

**并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。** 

# 三、封锁

## 封锁粒度

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查锁是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。需要在锁开销以及数据安全性之间做一个权衡。

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

## 封锁类型

### 1. 排它锁与共享锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

1. 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
2. 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

| - | X | S |
| :--: | :--: | :--: |
|X|No|No|
|S|No|Yes|

### 2. 意向锁

意向锁（Intention Locks）可以支持多粒度封锁。它本身是一个表锁，通过在原来的 X/S 锁之上引入了 IX/IS，用来表示一个事务想要在某个数据行上加 X 锁或 S 锁。

有以下两个规定：

1. 一个事务在获得某个数据行对象的 S 锁之前，必须先获得 IS 锁或者更强的锁；
2. 一个事务在获得某个数据行对象的 X 锁之前，必须先获得 IX 锁。

各种锁的兼容关系如下：

| - | X | IX | S | IS |
| :--: | :--: | :--: | :--: | :--: |
|X    |No    |No |No | No|
|IX    |No    |Yes|No | Yes|
|S    |No    |No    |Yes| Yes|
|IS    |No    |Yes|Yes| Yes|

## 封锁协议

### 1. 三级封锁协议

**一级封锁协议** 

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么一个事务的修改就不会被覆盖。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-x(A) | |
| read A=20 | |
| | lock-x(A) |
|  | wait |
| write A=19 | |
| commit | |
| unlock-x(A) | |
| | obtain |
| | read A=19 |
| | write A=21 |
| | commit |
| | unlock-x(A)|

**二级封锁协议** 

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-x(A) | |
| read A=20 | |
| write A=19 | |
| | lock-s(A) |
|  | wait |
| rollback | |
| A=20 | |
| unlock-x(A) | |
| | obtain |
| | read A=20 |
| | commit |
| | unlock-s(A)|

**三级封锁协议** 

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

| T<sub>1</sub> | T<sub>1</sub> |
| :--: | :--: |
| lock-s(A) | |
| read A=20 | |
|  |lock-x(A) |
| | wait |
|  read A=20|  |
| commit | |
| unlock-s(A) | |
| | obtain |
| | read A=20 |
| | write A=19|
| | commit |
| | unlock-X(A)|

### 2. 两段锁协议

加锁和解锁分为两个阶段进行，事务 T 对数据 A 进行读或者写操作之前，必须先获得对 A 的封锁，并且在释放一个封锁之后，T 不能再获得任何的其它锁。

事务遵循两段锁协议是保证并发操作可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(c)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(c)...unlock(C)...
```

# 四、隔离级别

<font size=4>  **1. 读未提交（READ UNCOMMITTED）** </font> </br>

事务中的修改，即使没有提交，对其它事务也是可见的。

<font size=4>  **2. 读已提交（READ COMMITTED）** </font> </br>

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

<font size=4>  **3. 可重复读（REPEATABLE READ）** </font> </br>

保证在同一个事务中多次读取同样数据的结果是一样的。

<font size=4>  **4. 可串行化（SERIALIXABLE）** </font> </br>

强制事务串行执行。

<font size=4>  **四个隔离级别的对比** </font> </br>

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| :---: | :---: | :---:| :---: |
| 未提交读 | YES | YES | YES |
| 提交读 | NO | YES | YES |
| 可重复读 | NO | NO | YES |
| 可串行化 | NO | NO | NO |

# 五、多版本并发控制

（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。mvcc主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，读操作只读该事务开始前的数据库的快照，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

## 核心思想

MVCC是通过保存数据在某个时间点的快照来进行控制的。使用MVCC就是允许同一个数据记录拥有多个不同的版本。然后在查询时通过添加相对应的约束条件，就可以获取用户想要的对应版本的数据。

## 实现过程

需要使用undo log  和快照去实现。undo log 是保存了数据修改以前的版本信息，快照用于进行快照读时进行可见性判断，快照中包含了当前事务的id，当前活跃事务的最小id，当前活跃事务的最大id，当前活跃事务的列表，将要查询的数据行的的ID与快照中活跃事物的ID进行比较，

1. 如果大于当前活跃事物的最大ID，说明要查询的数据在当前事物之后才出现，对当前事物不可见，从要查询数据以前的版本中再进行比较；
2.  如果要查询数据行的ID小于当前活跃事物的最小ID，说明数据是在当前事务之前创建，对当前事务可见；
3. 如果要查询数据行的ID介于最大事务id和最小事务ID之间，判断数据id是否存在活跃事务列表中，如果存在，因为事务未提交所以是不可见的，如果不存在，说明是可见的。

## 读已提交和可重复读的实现方式

* **读已提交**：每次进行检索之前都创建新的快照
* **可重复读**：第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用这个read_view。所以能保证每次读取的一致性，即都是读取第一次读取到的内容（可重复读的语义）

### 1. SELECT

该操作必须保证多个事务读取到同一个数据行的快照，这个快照是最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。

当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

把没对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。

除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

### 2. INSERT

将系统版本号作为数据行快照的创建版本号。

### 3. DELETE

将系统版本号作为数据行快照的删除版本号。

### 4. UPDATE

将系统版本号作为更新后的数据行快照的创建版本号，同时将系统版本号作为作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。

## 快照读与当前读

### 1. 快照读

快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

引入快照读的目的主要是为了免去加锁操作带来的性能开销，但是当前读需要加锁。

```sql
select * from table ....;
```

### 2. 当前读

它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update ;
delete;
```

# 六、Next-Key Locks

Next-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，MVCC + Next-Key Locks，就可以防止幻读的出现。

## Record Locks

锁定的对象是索引，而不是数据。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。

## Grap Locks

锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合。在 user 中有以下记录：

```sql
|   id | last_name   | first_name   |   age |
|------|-------------|--------------|-------|
|    4 | stark       | tony         |    21 |
|    1 | tom         | hiddleston   |    30 |
|    3 | morgan      | freeman      |    40 |
|    5 | jeff        | dean         |    50 |
|    2 | donald      | trump        |    80 |
+------|-------------|--------------|-------+
```

那么就需要锁定以下范围：

```sql
(-∞, 21]
(21, 30]
(30, 40]
(40, 50]
(50, 80]
(80, ∞)
```

# 七、关系数据库设计理论

## 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 W->A，如果能找到 W 的真子集 W'，使得 W'-> A，那么 W->A 就是部分函数依赖，否则就是完全函数依赖；

## 异常

不符合范式的关系，会产生很多异常，主要有以下四种异常：

1. 冗余数据，例如学生-2 出现了两次。
2. 修改异常，修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
3. 删除异常，删除一个信息，那么也会丢失其它信息。例如如果删除了课程-1，需要删除第二行和第三行，那么学生-1 的信息就会丢失。
4. 插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

## 范式

为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

### 1. 第一范式 (1NF)

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式

### 2. 第二范式 (2NF)

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。

### 3. 第三范式 (3NF)（确保非主键的列没有传递依赖）

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。

## 4.  BC 范式（BCNF）

主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。

# MYSQL 存储引擎

* **概念：**数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。
* 种类
  1. InnoDB
  
  2. MyISAM
  
  3. MEMORY
  
      memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景
* 区别

  1. InnoDB支持事务，和容灾恢复，MyISAM不支持。
  2. InnoDB支持外键，而MyISAM不支持，对一个包含外键的 InnoDB 表转为 MYISAM 会失败
  3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和索引绑在一起的，MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，在myisam中叶子节点存储的是所在行的物理地址，在innodb中叶子节点存储了所在行的数据。
  4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
  5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
  6. InnoDB表必须有主键(用户没有指定的话会自己找或生产一个主键)，而Myisam可以没有

* 解释

  1. 主键：唯一标识表中每行的这个列（或这组列）成为主键

  2. 外键：如果一个字段X在一张表（表一）中是主关键字，而在另外一张表（表二）中不是主关键字，则字段X称为表二的外键；换句话说如果关系模式R1中的某属性集不是自己的主键，而是关系模式R2的主键，则该属性集称为是关系模式R1的外键

  3. 索引

     索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。

  4. 聚集索引

     数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引，聚集索引时叶结点存储的是数据

  5. 非聚集索引

     该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。，非聚集索引叶结点存储的是指向数据的指针，**查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据**。

  6. 聚集索引与非聚集索引的使用

     1. 使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
     2. 非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升



# mysql执行一条查询语句的内部执行过程

1. 连接器：客户端先通过连接器连接到Mysql服务器
2. 缓存：连接器权限验证通过后，先查询是否有查询缓存，如果有缓存，则直接返回缓存数据，如果没有缓存数据则进入分析器
3. 分析器：分析器会对查询语句进行语法分析和词法分析，判断SQL语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器
4. 优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好
5. 执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询对比了，直到查询到满足条件的所有数据，然后返回。

# 索引

一个索引是存储的表中一个特定列的值的数据结构，B+树是最常用的用于索引的数据结构。

notes：**数据库索引并不存储这个表中其他列（字段）的值**，索引存储了指向表中某一行的指针

## 数据库的索引类型

数据库的索引类型分为逻辑分类和物理分类

1. 逻辑分类

   * 主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。
   * 唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。
   * 普通索引 一张表可以有多个普通索引，可以重复可以为空值
   * 全文索引 可以加快模糊查询，不常用

2. 物理分类

   1. 聚集索引

      数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引，聚集索引时叶结点存储的是数据

   2.非聚集索引

   ​	该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。，非聚集索引叶结点存储的是指向 数据的指针，**查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据**。

3. 数据结构

   哈希索引

   B+树

## 哈希索引

哈希索引在寻找值时哈希表效率极高。哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力

# 事务是怎么实现的

事务指的是一个或一组sql语句组成一个执行单元，这个执行单元构成一个上的整体，要么全部执行，要么全部不执行，具有原子性，一致性，隔离性，持久性（ACID）的特点，实现事物就是要保证可靠性和并发性，而这些是靠日志恢复和并发控制实现的。

* 日志恢复：

  数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的**持久性**。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证未提交事务的**原子性**。

* 并发控制：

* 并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的**隔离性**。MVCC通过为数据添加时间戳来实现

# 数据的锁的种类，加锁方式

* 按照类型来分有乐观锁和悲观锁
* 按照粒度来分有行级锁，页级锁，表级锁
* 按照作用来分有共享锁和排他锁

# 什么是共享锁和排他锁

* 共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。
* 排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）

# 分库分表的理解和简介

* 分表

  单表数据量太大，会极大影响你的 sql 执行的性能，到了后面 sql 可能就跑的很慢了。就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。

* 分库

一个库的数据拆分到多个库中，访问的时候就访问一个库好了。更好的适应高并发问题

# 分库分表中间件

TDDL，mycat

# 数据库水平拆分或垂直拆分

* 水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。

* 垂直拆分

把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。

# 数据库高并发的解决方案

1. 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担
2. 增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）
3. 主从读写分离，让主服务器负责写，从服务器负责读。
4. 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度
5. 使用分布式架构，分散计算压力

# 乐观锁和悲观锁

一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对1数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。

悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。

# 乐观锁和悲观锁怎么实现的

* 悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。

* 乐观锁有三种常用的实现形式
  1. 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决
  2. 一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。
  3. 最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似



