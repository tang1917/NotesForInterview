# 线程池和模拟Proactor模式实现的并发模型

## **并发模式**

并发编程的主要目的是让程序“同时“执行多个任务，如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率变低；但如果程序是I/O密集型的，比如经常读写文件访问数据库，使用并发编程能够提高CPU的利用率；这主要是因为I/O的操作速度远没有CPU的计算速度快，所以让程序阻塞于I/O操作将浪费大量CPU时间。如果程序有多个执行线程，则当前被I/O阻塞的线程可以放弃CPU，将执行权限交给其他线程。

* 半同步/半异步模式
  * 同步指程序按照代码的序列的顺序执行，异步指程序的执行需要有系统事件来驱动
  * **同步线程用于处理客户逻辑**；异步线程用于处理I/O事件
* 高效的半同步/半异步模式，主线程只管理监听SOCKET，连接SOCKET由工作线程来处理，当有新的连接到来时，主线程就接受之并将新返回的连接SOCKET派发给某个工作线程，此后该新SOCKET上的任何操作都有工作线程来处理，直到客户关闭连接。
* 领导者/追随者模式

为什么使用进程池或者线程池

* 动态创建进程或者线程比较耗时间，将导致较慢的客户响应
* 动态创建的子进程或者子线程通常只用来为一个客户服务，这将导致系统上产生大量的细微进程或线程，进程或线程的切换将消耗大量的CPU时间
* 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎的管理其分配的文件描述符和堆内存等系统资源，否则子进程可能会复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。

##  半同步/半异步+线程池

**主线程负责监听所有SOCKET上的事件，如果监听SOCKET上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接SOCKET，然后往epoll内核事件表中注册该SOCKET上的读写事件。如果连接SOCKET有读写事件发生，读写事件发生，即有新的客户请求到来或有数据要发送到客户端，主线程就将该连接socket插入请求队列中。所有的工作线程都睡眠在请求队列上，当有任务到来时他们通过竞争来获得新任务的接管权。**

# 处理http连接

## 使用主从状态机处理用户请求

在解析客户请求时，主状态机有三种状态：处理请求行状态，处理请求头部状态，处理请求体状态；初始状态为请求行状态。

从状态机主要分析请求数据，找出请求行，请求头部，请求体的结束依据\r\n,\r\n+空格；主要有获得完整请求，未获得完整请求，请求错误三种状态。

状态机调用从状态机，从状态机读取完整的请求行，之后解析请求行；主状态机之后改变状态为请求头部状态，从状态机读取完整的请求头部，主状态机解析请求头部后将状态改为处理请求体，从状态机读取完整的请求体，主装状态机分析；

# 使用升序链表定时器处理不活跃的连接

服务器需要定期检测一个客户连接的活动状态**，因此通过使用定时器以及某种容器类数据结构将定时器串联起来，以实现对定时时间的统一管理。**高效的管理定时器的容器有时间轮和时间堆。

* 时间轮定时器

  * **指针指向轮子上的一个槽，它以恒定的速度顺时针转动，每转动一步，就指向下一个槽，每次转动称为一个滴答。每个槽指向一个定时器链表，每条链表上定时器具有相同的特征：它们的定时时间相差N*si的整数倍。时间轮利用这个关系将定时器散列到不同的链表中。这样插入一个定时器的时间复杂度是o(1),删除一个定时器的时间复杂度是o(1),执行一个定时器任务的时间复杂度是o(n)**

* 时间堆定时器

  **将所有定时器中超时时间最小的一个定时器的超时值做为心搏间隔。这样一旦心搏函数被调用，超时时间最小的定时器必然到期，之后就处理该定时器；之后再从剩余定时器中找出超时时间最小的一个，并将这段最小时间设置为心搏间隔。**

## 日志系统

日志系统可以选择同步/异步两种模式，主要涉及两个模块，一个是日志模块，一个是阻塞队列模块，阻塞队列模块主要是为解决异步写入日志做准备

异步日志的实现主要是往阻塞队列中添加待写日志，然后唤醒所有使用队列的线程

当写日志时，如果当前队列没有元素，线程会阻塞，等待条件变量满足。

# web服务器整体工作过程

## 线程池+半同步/半异步的模式实现并发

1. 动态创建进程或者线程比较耗时间，将导致较慢的客户响应；

2. 动态创建的子进程或者子线程通常只用来为一个客户服务，这将导致系统上产生大量的细微进程或线程，进程或线程的切换将消耗大量的CPU时间

半同步/半异步模式是异步线程的特点是执行效率高，实时性强，但异步方式执行的程序相对复杂，难于调试和扩展，并且不适合于大量并发；同步线程的特点是效率性较低，实时性差但逻辑简单。在程序中异步线程用于处理I/O事件，同步线程用于处理客户逻辑。

**主线程负责监听所有SOCKET上的事件，如果监听SOCKET上有可读事件发生，表明有新的连接请求到来，主线程就接受之以得到新的连接SOCKET，然后往epoll内核事件表中注册该SOCKET上的读写事件。同时初始化一个连接；如果连接SOCKET有读写事件发生，即有新的客户请求到来或有数据要发送到客户端，主线程就将该连接socket插入请求队列中。所有的工作线程当有任务到来时他们通过竞争来获得新任务的接管权。**

## 处理请求数据

当连接socket上有可读事件发生时，读取数据到内存中，之后用主从状态机去分析数据，从状态机找到http报文中完整的请求头部，然后主状态机分析头部，得到请求方法，统一资源标识符（url），版本号等信息，之后从状态机再去报文中找到完整的请求头部，主状态机再根据请求头部获取头部信息，之后从状态机得到请求体，主状态机分析请求体中的信息。完整解析了http报文后主状态机根据解析的数据处理响应的请求。

## 处理非活动的连接

服务器需要定期检测一个客户连接的活动状态**，因此通过使用定时器以及某种容器类数据结构将定时器串联起来，以实现对定时时间的统一管理。

**利用alarm函数周期性的触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务--关闭非活动连接，也就是从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器**；常用的定时器还有时间轮定时器和时间堆定时器。

## 日志系统

实现了可以选择同步或者异步方式记录服务器的运行状态；

## I/O模型：事件的通知机制

* 阻塞I/O:程序阻塞于读写函数
* I/O复用：程序阻塞于I/O复用系统调用，但可同时监听多个I/O事件。对I/O本身的读写操作是非阻塞的
* SIGIO信号：**信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段**
* 异步I/O：**内核执行读写并触发读写完成事件。程序没有阻塞阶段。**

## 同步I/O

* 阻塞I/O,I/O复用,SIGIO信号
* 原因：**I/O的读写操作都是在I/O事件发生后，应用程序来完成读写操作；异步I/O是内核完成读写操作**。

# 户型图

## 项目目的

这个项目是我们导师和华为的一个部门还有贝壳找房合作的一个项目

给出一张户型图识别出图中承重墙、非承重墙、家具、门、窗的位置，输出一份CSV格式的数据和一份dxf格式的数据，CSV格式的数据主要用来建立房子的3D模型，而DXF的数据用来做WIFI信号仿真，我们负责的只是项目的一个环节，也就是提供数据，具体的怎么建立3D模型和wifi信号仿真不算我们负责的。

项目主要一个难点就是墙体位置和类型的确定。刚开始尝试的方法有找出墙体的边缘或者墙体的角点，这种方法对一些简单的户型适用，对一些复杂的户型很难再通过这种方法分析，最后采用了一种对墙体进行骨架提取，细化成宽度为单像素的线条，先找出它们所在的直线，之后确定线条在直线上的端点，用两个端点坐标表示墙体的位置信息。具体来说，我首先根据墙体颜色都是黑色这个特点，根据黑色在颜色空间中的分布范围，提取出黑色，其他颜色都变成背景。这样就在图中获得墙体区域，将墙体细化成宽度为单像素线条的思想是：一个像素周围有8个相邻的像素，也就是256中情况，我建立一个哈希表统计这256中情况哪些情况能把当前像素点从前景变为背景，哪些不能，原则就是：**1. 内部点不能删除；2.孤立点不删除；3.直线的端点不删除；如果是p是边界点，去掉P之后，如果连通分量不增加，则这个点可以删除**。按照这个方法迭代到像素不再发生变化为止，得到了宽度为单像素的线条。之后就是确定线条所在的直线，原理就是坐标空间上的一条直线y=kx+b映射到参数空间是一个点（k,b）,坐标空间中一条直线的每个点对应到参数空间就是一条直线，这些直线都会相交于（k,b）这个点，根据这个原理，如果参数空间的（k,b）这个点被大于t条直线相交那么对应到坐标空间他就应该代表一条直线。通过这种方法确定了直线，之后在确定线条在这条直线上的起始点和终止点获得端点的坐标信息。

有了墙体的位置信息后再去判断墙体的类型信息，也就是他是承重墙还是非承重墙，先找到墙体最外围一圈的墙体出现最多的宽度，认为是承重墙宽度，再根据比例关系得到非承重墙宽度。这个就是墙体位置和类型的确定过程。之后就是进行一个优化，保证墙体是对齐和唯一的；窗户和门的确定就是根据墙体的间隙确定的。最后是家具的确定，对于家具使用的一种深度学习的方法，我们再网上找七八千张图片进行一个标注出家具的真实位置，做成一个数据集，放到一个深度神经网络中去训练，之后使用训练好的模型去预测家具的位置和类型。

我负责的这部分最后产生了一个专利。

# faster rcnn

卷积层：提取图像特征：

* 它的多层结构能自动学习特征，并且可以学习到多个层次的特征：较浅的卷积层感知域较小，学习到一些局部特征；较深的卷积层具有较大的感知域，能够学些到更加抽象的特征。这些抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于识别性能的提高。

* rpn网络：在从卷积层得到的feature map的每个位置，回归区域的边界与目标得分。
* ROI层：
  * 该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。
* Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置

# 多目标跟踪

在给定视频中同时对多个感兴趣的目标进行定位，并且维持他们的ID、记录他们的轨迹。

随着目标检测器性能的提升，基于检测的跟踪算法称为近些年来主要的跟踪算法，这类算法的主要思想是首先使用目标检测器确定目标每一帧中的位置，之后根据目标的运动信息，外观特征进行关联，保持目标在序列中的身份，形成轨迹。目标的重新识别，目标的遮挡，目标的外观变化是这类算法要解决的主要任务。

**我论文的主要一个创新点是对目标遮挡的处理，如果发生了目标遮挡，那么目标检测器检测出的位置信息就不够精确，我的做法是使用传统的卡尔曼滤波器预测位置同时使用目标检测器检测目标，对这些候选的目标使用一个评分函数统一打分，**

# 实习做的事情

我在云核心网增值开发部下面的融合数据维护部实习，我们部门主要负责5G网络中的UDM网元和234G中的HSS网元的运营维护，这两个网元在通信网络中主要是用来存储用户信息和用户签约的业务数据，我们主要是是对预警和事故进行处理，完成产品的数据迁移和设备扩容操作。我在部门里是学习了这些通信网络知识和微服务相关知识，比如5G网络中的各个网元以及他们实现什么功能，同时做一些维护工具的开发，实习期间我完成了两个工具一个是号段统计工具，一个是日志分析工具。

K8s**: k8s是一个编排容器的工具，其实也是管理应用的全生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且可以做到故障自愈，例如一个服务器挂了，可以自动将这个服务器上的服务调度到另外一个主机上进行运行，无需进行人工干涉。**

# 实习收获：

**提高了我通过编程解决实际问题的能力，对多进程和多线程编程有了更深的理解，**多进程和多线程都是并发编程的实现方式，如果程序是I/O密集型的，比如经常读写文件，由于I/O操作速度远没有CPU计算速度快，所以让程序阻塞于I/O操作将浪费大量的CPU时间，如果程序有多个子进程并发执行，则当前被I/O操作阻塞的的执行线程可主动放弃CPU，并将执行权转移到其他子进程，这样一来，CPU就可以用来做更加有意义的事情，而不是等待I/O操作的完成，因此CPU的利用率显著提升，但如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使得效率降低。

**还有就是我自己对这两个月的实习进行一个总结和反思，对如何更好的更高效的工作有了一个自己的认识，**首先是拿到一个任务之后，首先要明确需求分析，明确好之后再做下一步工作，避免把精力和时间浪费在一个不重要的需求或者错误的方向上；然后是先解决主要问题，把主要任务完成之后再去优化细节；最后是要融入团队，和别人多交流，这样的话才才能激发自己的灵感和工作热情。

**最后就是对网络通信这方面知识有了一个深入的了解**，比如2/3/4G网络的组成和基本的通信过程，还有5G网络的特点等。5G网络的主要特点有两个：

**1.将用户面功能抽象为多个独立的网络服务，以软件化，模块化，服务化的方式构建网络**

2. **控制面和用户面的分离，让用户面功能摆脱中心化的束缚，使其既可以部署于核心网也可以部署与更靠近用户的接入网。**

# 换部门原因

我所在的实习部门主要做的是对华为的通信网络产品做维护的，需要的更多的是沟通协调能力和对问题的定位解决能力，我现在更想去提高自己的编程能力，学习更多的技术；然后我了解到消费者软件部是做业界领先的分布式OS，如果能来这个部门符合我自己的兴趣方向，另外我认为做终端系统是很有价值和伟大的事，这能为我工作增加很多的动力。

# 自我介绍

**

# 亮点

首先我认为自己有在工作中解决实际问题的能力，熟悉开发过程，因为我完成了两个实际的项目，并且有一个项目获得了专利，在实习中我也解决了实际的问题，此外我对知识掌握的很全面，熟悉Linex，计算机网络，数据库，操作系统，对redis也有一定的了解，然后能够熟练的使用c++和python,而且我相信自己有能很快的学会其他语言的基础，因此我认为这方面是我的一个亮点。



# 最大的失败

大学的时候没有做好规划也没有明确的目标，导致最后没能保研成功，之后又选择了考研，这个过程浪费了很多时间，但也是通过考研磨练了我的意志，让我养成了好的学习习惯，这也是大学获得的最大的收获了。

# 最大的优点

我认为自己最大的优点是能够一直持续稳定的让自己进步和发展。我每到一个环境就能很快的调整自己，找到目标，然后通过努力和对自己的严格要求，使自己达成目标。我从来不会躺平，我觉得活着就应该不断的学习和完善自己，这是我的生活态度，我在从初中，高中，到大学，再到读研，每次到一个新的环境我都显得很普通，但是在这个过程中我能够保证自己不掉队，并且慢慢的进步，到最后总能够让自己获得一个较大的发展。我认为这主要是我遇到困难能够咬牙坚持，然后靠勤奋的不断学习，去实习自己的目标。

# 最大的缺点

在工作和学习中有时候会因为想做的东西太多而分不清主次，比如我很多时候看书的话不喜欢跳着看，喜欢从前到后通读，不想放过每一个知识点，但这样会效率低，抓不住重点。

还有就是理想主义，也可能是因为太年轻，我做选择喜欢遵循内心的想法，对现实中的利益风险这些权衡考虑的比较少，比如找工作这件事，我实习部门的hr跟我说秋招还投他们部门，因为在部门实习过，面试的时候会有优势一些，但我在做选择的时候对这些因素考虑的会比较少，还是会选择自己心仪的部门，然后也很多时候因为自己这种理想主义导致更多的失败。

# 科研和找工作分配

# 对华为的看法

华为是一个很了不起的公司，在很多行业都能做到一流，我在华为两个月的实习感受就是同事们工作都很认真尽责，经常为了一个问题很激烈的讨论好久，还经常开问题总结会，还定期的串讲自己所部分工作的知识，互相学习。这说明公司的制度很完善，每个人都能在不断的学习。

# 学习的方式

基础知识相比看书来说我更喜欢看书学习因为我觉得看书学习比较快，但有些难以理解的部分会去网上看看相应的博客或者视频讲解。此外我更喜欢通过实践或者说项目学习，这样能够对知识理解的更深刻，能力的提高也比较快。

# 最近看了什么书

为了找工作技术书最近看的是redis的设计与实现，mysql必知必会，计算机网络，操作系统，c++primer,算法图解这些是去年看的，闲书的话最近一年看了哲学家都干了些什么，资治通鉴的精选版，红楼梦和三体。

# 最大的挑战

**考研应该来说是我遇到的最大的挑战，因为我是毕业后考的研，面临着更大的压力，还有就是考研需要准备的时间很久，每天都要学习十多个小时，放松休息的时间很少，能坚持下来挺不容易的。还好最后有了一个好的结果。**

**坚持然后不断的调整心态，使自己尽量保持一个好的学习状态。还有就是找个小伙伴一起努力，更容易坚持下来。**

# 如何看待996

996的工作肯定比我现在幸福多了，我读研期间基本上就是9117，所以我肯定能接受这样的工作方式，但希望工资也能跟上。

# 如何看待狼性文化

狼性文化我认为是在这个时代我们的民族企业要生存要发展去达到世界一流必然要做出的必然选择。因为别的很多企业在我们发展之前都已经发展起来了，要想能够追赶上它们与它们竞争就需要这种狼性文化。公司在发展的同时，也给了员工很丰厚的待遇，让员工实现了自己的价值，从这个方面来说是一种双赢的结果。

# 科研项目

多目标跟踪，

# 职业规划

现在面临秋招，我理想的规划就是能去华为或者BAT这样的大厂，去一个技术氛围好的部门，然后去太高自己的能力，希望在几年之后也能称为一个领域内的大佬
