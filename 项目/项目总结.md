# 线程池和模拟Proactor模式实现的并发模型

## **并发模式**

并发编程的主要目的是让程序“同时“执行多个任务，如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率变低；但如果程序是I/O密集型的，比如经常读写文件访问数据库，使用并发编程能够提高CPU的利用率；这主要是因为I/O的操作速度远没有CPU的计算速度快，所以让程序阻塞于I/O操作将浪费大量CPU时间。如果程序有多个执行线程，则当前被I/O阻塞的线程可以放弃CPU，将执行权限交给其他线程。

* 半同步/半异步模式
  * 同步指程序按照代码的序列的顺序执行，异步指程序的执行需要有系统事件来驱动
  * **同步线程用于处理客户逻辑**；异步线程用于处理I/O事件
* 高效的半同步/半异步模式，主线程只管理监听SOCKET，连接SOCKET由工作线程来处理，当有新的连接到来时，主线程就接受之并将新返回的连接SOCKET派发给某个工作线程，此后该新SOCKET上的任何操作都有工作线程来处理，直到客户关闭连接。
* 领导者/追随者模式

为什么使用进程池或者线程池

* 动态创建进程或者线程比较耗时间，将导致较慢的客户响应
* 动态创建的子进程或者子线程通常只用来为一个客户服务，这将导致系统上产生大量的细微进程或线程，进程或线程的切换将消耗大量的CPU时间
* 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎的管理其分配的文件描述符和堆内存等系统资源，否则子进程可能会复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。

##  半同步/半反应堆线程池

**主线程负责监听所有SOCKET上的事件，如果监听SOCKET上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接SOCKET，然后往epoll内核事件表中注册该SOCKET上的读写事件。如果连接SOCKET有读写事件发生，读写事件发生，即有新的客户请求到来或有数据要发送到客户端，主线程就将该连接socket插入请求队列中。所有的工作线程都睡眠在请求队列上，当有任务到来时他们通过竞争来获得新任务的接管权。**

# 处理http连接

## 使用主从状态机处理用户请求

在解析客户请求时，主状态机有三种状态：处理请求行状态，处理请求头部状态，处理请求体状态；初始状态为请求行状态。

从状态机主要分析请求数据，找出请求行，请求头部，请求体的结束依据\r\n,\r\n+空格；主要有获得完整请求，未获得完整请求，请求错误三种状态。

状态机调用从状态机，从状态机读取完整的请求行，之后解析请求行；主状态机之后改变状态为请求头部状态，从状态机读取完整的请求头部，主状态机解析请求头部后将状态改为处理请求体，从状态机读取完整的请求体，主装状态机分析；

# 使用升序链表定时器处理不活跃的连接

服务器需要定期检测一个客户连接的活动状态，因此通过使用定时器以及某种容器类数据结构将定时器串联起来，以实现对定时时间的统一管理。高效的管理定时器的容器有时间轮和时间堆。

* 时间轮定时器

  * 指针指向轮子上的一个槽，它以恒定的速度顺时针转动，每转动一步，就指向下一个槽，每次转动称为一个滴答。每个槽指向一个定时器链表，每条链表上定时器具有相同的特征：它们的定时时间相差N*si的整数倍。时间轮利用这个关系将定时器散列到不同的链表中。这样插入一个定时器的时间复杂度是o(1),删除一个定时器的时间复杂度是o(1),执行一个定时器任务的时间复杂度是o(n)

* 时间堆定时器

  将所有定时器中超时时间最小的一个定时器的超时值做为心搏间隔。这样一旦心搏函数被调用，超时时间最小的定时器必然到期，之后就处理该定时器；之后再从剩余定时器中找出超时时间最小的一个，并将这段最小时间设置为心搏间隔。

## 日志系统

日志系统可以选择同步/异步两种模式，主要涉及两个模块，一个是日志模块，一个是阻塞队列模块，阻塞队列模块主要是为解决异步写入日志做准备

异步日志的实现主要是往阻塞队列中添加待写日志，然后唤醒所有使用队列的线程

当写日志时，如果当前队列没有元素，线程会阻塞，等待条件变量满足。

