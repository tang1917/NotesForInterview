# 语言对比===

# C和C++的区别

* 思路
  * 面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现
  * 面向对象的思路：面向对象是对事物的一种抽象，抽象出事物的属性和方法，更有利于程序的扩展维护和重用。面向对象有三大特性：封装，继承和多态。
    * 将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性，实现了代码模块化，如类里面的private和public；
    * 继承使得子类可以复用父类的成员和方法，实现了代码重用；
    * 多态则是“一个接口，多个实现”，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。
* 内存管理不一样，c使用malloc和free，c++除此之外还有new和delete
* c++中还有重载和引用等概念，而c中没有

# c++，Java的联系和区别

* C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高
* C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收
* C++有指针，Java没有指针，只有引用
* JAVA和C++都有构造函数，但是C++有析构函数但是Java没有

# C++和python的区别

* python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高
* python使用缩进来区分不同的代码块，C++使用花括号来区分
* C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
* python的库函数比C++的多，调用起来很方便



# 面向对象===

## # 多态

多态是面向对象程序设计的一个重要特征。多态的字面意思是多种状态，在面向对象语言中，一个接口多种实现为多态。c++中的多态具体体现在编译和运行两个阶段。编译时多态是静态多态，运行时多态为动态多态，具体引用的接口在运行时确定。

## 作用

封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。静态多态，将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。动态多态，则不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。

## c++中实现多态的三种方式

1. 函数重载
2. 模板函数
3. 虚函数
   **其中函数重载和模板函数是静态多态，虚函数是动态多态，静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择合适的函数，，动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己该调用哪一类虚函数**。

### 函数重载

允许有不同参数的函数有相同的名字，根据调用时函数的参数列表，选用不同的函数（不将引用和本身作为不同的特征标，同时不区分const常量和非const常量，会尝试使用标准类型转换强制进行匹配）

### 函数模板

#### 概念

函数模板是通用的函数描述，他们使用泛型来定义函数，其中的泛型可用具体的类型（如int或double)替换。

#### 用法

在定义和声明前加 template <typename T>

#### 模板的局限性

编写的模板函数可能无法处理某些类型

#### 显示具体化

无法使用模板重载其他代码，可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，使用该定义，而不在寻找模板
用法：
eg: template<>void Swap<job>(job&,job&)

#### 实例化和具体化

隐式实例化，显示实例化：直接命令编译器生成实例
用法：
template void Swap<int>(int,int)

### 动态多态

动态多态最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而调用不同的方法。如果没有使用虚函数，即没有利用 C++ 多态性，则利用基类指针调用相应函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用同一个函数，这就无法达到“一个接口，多种实现”的目的了
**如果要在派生类中重新定义基类方法，使用虚函数，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果不定义为虚函数，程序将根据引用类型或者指针类型选择方法；如果定义为虚函数，它将根据引用或者指针指向的类型来选择方法。**
动态多态是通过“继承+虚函数”来实现的，只有在程序运行期间（非编译期）才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
**虚析构函数**确保释放派生对象时，按正确顺序调用析构函数。

# 虚函数工作原理

**在类中用 `virtual` 关键字声明的函数叫做虚函数，在创建该类的每一个对象时为每一个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表。虚函数表中存储了为类对象声明的虚函数的地址。如果派生类没有重写虚函数，则派生类没有提供虚函数的新定义，该虚函数表保存函数原始版本地址，如果提供了虚函数的新定义则在虚函数表中保存新的函数地址**。

# 静态联编和动态联编

* 静态
  * 在编译器编译过程中决定使用哪个函数
* 动态
  * 因为虚函数的存在，只能在程序运行中决定使用哪个函数。

# c++内存分布

* 堆

  * 操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还

* 栈

  

* 自由存储区

  * 自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区

* 全局/静态存储区

  * 全局变量和静态变量被分配到同一块内存中

* 常量存储区

  * 里面存放的是常量

## 作用域为类的常量

* static const int months = 12
* 使用枚举

# 关键字库函数

## sizeof和strlen的区别

* sizeof是c++中的运算符，而strlen是c++中的库函数
* sizeof**测量的是字符数组的分配大小，而strlen测量的是字符串的实际长度**
* sizeof在编译时确定长度而strlen在运行时确定长度
* sizeof的参数可以是类型，也可以是变量；strlen的参数必须是char*类型的变量

## explicit

作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。

## static

* 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里
* 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突
* 类：在类中，被static修饰的成员变量是类静态成员，**这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。**注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。
* 注意：
  * 类静态成员变量不能在类内初始化
    * 原因：类静态成员变量不依赖于类实体存在，可以通过类静态成员函数访问，即使类没有被实例化未一个对象，类静态成员变量已经存在；在类内初始化静态成员不符合静态语义。

## const

* `const` 修饰变量，定义成 `const` 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
* `const` 修饰函数参数，使得传递过来的函数参数的值不能改变
* 类内：
  * const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量
  * `const` 成员变量只能在类内声明、定义，在**构造函数初始化列表中初始化**

## const与define

* 联系：
  * 他们都能够定义常量
* 区别
  * 编译阶段：`define` 是在编译预处理阶段进行替换，`const` 是在编译阶段确定其值
  * 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
  * 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误

## inline

* 声明为内敛函数，编译器会在编译阶段将代码体嵌入内联函数的调用语句块中，而不是通过函数的调用机制，函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源。
* 类内定义成员函数默认是内联函数，可以不用在函数头部加 `inline` 关键字。
* 

# char *a和char[]b不同

* a是一个char类型指针变量，b是一个char型数组的名字
* char[]对应的内存区域总是可写的，char*指向的区域有时可写，有时只读
* 小结
  * const char * a=”string1”
  * char b[]=”string2”
    * a是const char *类型， b是char* const类型
    * a是一个指针变量，a的值（指向）是可以改变的，但a只能指向（字符串）常量，指向的区域的内容不可改变
    * b是一个指针常量，b的值（指向）不能变；但b指向的目标（数组b在内存中的区域）的内容是可变的

# delete和delete[]的区别

* delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数
* 用new分配的内存用delete释放，用new[]分配的内存用delete[]释放

# new,malloc

* malloc和free是c的动态内存管理方式，new和delete是c++的另外一种内存管理方式

* `malloc` ：成功申请到内存，返回指向该内存的指针；分配失败，返回 `NULL` 指针；`new` ：内存分配成功，返回该对象类型的指针；分配失败，抛出 `bac_alloc` 异常；

* 区别

  * `malloc`、`free` 是库函数，而`new`、`delete` 是关键字
    * `new` 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；`malloc` 在申请空间时，需要确定所申请空间的大小
    * new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。
    * `new` 分配失败时，会抛出 `bad_alloc` 异常，`malloc` 分配失败时返回空指针
    * 对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。**malloc、free 无法进行自定义类型的对象的构造和析构**
    * `new` 操作符从自由存储区上为对象动态分配内存，而 `malloc` 函数从堆上动态分配内存。（自由存储区不等于堆

* malloc的底层实现及其原理

  * **当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址**，不是数据段的末尾地址)；第一次读/写数据时，引起内核缺页中断，**内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)**

  * **当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。**

    * 原因：**brk****分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放****

  * mmap函数

    * mmap是一种**内存映射文件**的方法，即将**一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系**。实现这样的映射关系后，**进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。****相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享**。

    * 步骤：
      1. 分配内存空间
      2. 建立映射关系
      3. 访问这片映射空间，引发缺页异常，实现文件内容到物理内存的拷贝
    * 优点
      * 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率
      * 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉
      * 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的

  * 常规读文件

    1. 进程发起读文件请求

    2. 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode

    3. inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容

    4. 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。

## struct结构在C和C++中的区别

1. C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）
2. C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。
3. C++中，struct的成员默认访问说明符为public（为了与C兼容），class中的默认访问限定符为private，struct增加了访问权限，且可以和类一样有成员函数。
4. struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特

## struct和union的区别

1. 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
2. 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响
3. 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。

# 指针和引用

## 概念：
指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原来变量的一个别名。
## 不同：
* 引用不可以为空，当被创建时，必须初始化，而指针可以为空值，可以在任何时候初始化；
* 指针和引用的自增运算意义不一样；
* 指针是一个新变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量本身的操作。
* 指针可以有多级而引用只有一级

ps:const 在类型之前可以修改指针包含的地址，不能修改指针指向的值
const在变量类型之后--可以修改指针指向的值，但不能2修改指针的地址；

# 野指针

**指向不可用内存区域的指针**。如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起崩溃。野指针具有很强的隐蔽性，if语句对它不起作用。

产生原因：

* 指针变量没有被初始化
* 指针指向的内存被释放了，指针本身没有置NULL
* 指针超过了变量的作用范围

## 引用的用处

1. 引用经常用作函数的参数，按引用传递参数可以使用原始数据，**效率更高**
2. 有时候比起使用**指针更加安全**，使用指针经常换的的错误是1.操作空指针。2.操作野指针。3.误操作改变指针的值，使用引用可以便面这些问题，因为不存在空引用，引用必须初始化保证不是野指针，一个引用永远指向他初始化的那个对象。
3. 程序员能**够修改调用函数中的数据对象**；

## 为什么有了引用还需要指针
因为要兼容c语言
## 为什么有了指针还需要引用
**支持运算符重载，使得重载的运算符更符合操作习惯**。

# 友元函数
## 作用：
c++控制对类对象私有部分的访问，通常公有类方法提供唯一的访问途径，但这种限制有时候太严格，以至于不适合特定的编程问题。这种情况下，c++提供了另外一种形式的访问权限，友元。
友元有三种：

1. 友元函数；
2. 友元类；
3. 友元成员函数。
## 创建友元函数
一、将其原型放到类声明中，并在原型前面加上关键字friend
二、编写函数定义，因为它不是成员函数，所以不需要使用类限定符。同时不要在定义中使用关键字friend。
## 功能

* 虽然友元函数在类声明中声明，但他不是成员函数，因此不饿能使用成员运算符来调用
* 虽然友元函数不是成员函数，但它与成员函数的访问权限相同

# 构造函数与析构函数

# this指针
# const static #define

# 类继承
## **三种继承**

1. 公有继承

  **不改变基类成员的访问权限**

2. 保护继承

  **将基类中public成员变为子类的protected成员，其他成员访问权限不变**

3. 私有继承

   **使得基类所有成员在子类中的访问权限变为private**

4. **基类中的private成员不受继承方式的影响，子类永远无权访问**

* 派生类对象具有的特征
1. 派生类对象储存了积累的数据成员（继承了基类的实现）
2. 派生类对象可以使用基类的方法（继承了基类的接口）
* 派生类需要的操作
1. 派生类需要自己的构造函数
 基类对象应该在程序进入派生类对象构造函数之前被创建，使用成员初始化列表来完成这种工作。
2. 派生类可以根据需要添加额外的数据成员和成员函数

* 派生类引用和基类引用的特殊关系
基类指针可以在不进行显示类型转换的情况下指向派生类对象；
基类引用可以在不进行显示类型转换的情况下引用派生对象；
但只能调用基类方法。

## 抽象基类

## 用法：
从两个类中找到他们的共性，放到抽象基类中去；
## 纯虚函数
**当类声明中包含纯虚函数时，不能创建该类的对象，只把包含纯虚函数对象的类用作基类，要成为真正的抽象基类必须包含至少一个纯虚函数。在类中可以不定义该函数。**

* 使用场景
当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数

### 声明
在原型中加=0，使虚函数成为纯虚函数。

# 动态内存分配

# c++的6大组件
## 容器
容器是存放数据的类模板，可变长数组、链表、平衡二叉树等数据结构在STL(标准模板库)中都被实现为容器

* 顺序容器（vector,deque,list）
元素在容器中的位置与元素值无关，即元素不是排序的，将元素插入容器时指定在什么位置插入，元素就位于什么位置。
* 关联容器（set,multiset,map,multimap）
关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。

## vector

特点：

内存可增长的动态数组

数据结构：线性连续内存空间

三个迭代器：一个指向vector容器对象的起始字节位置；一个指向当前最后一个元素的末尾字节；还有一个指向整个vector容器占用内存空间的末尾字节。

## deque

一种双向开口的存储空间分段连续的数据结构，每段数据空间内部是连续的，而每段数据空间之间则不一定连续。

### deque与vector的最大差异

1. 允许常数时间内对两端元素进行插入和删除
2. 没有所谓的的容量概念，因为它是以分段连续空间组合而成，随时可以增加一段新空间并连接起来

## 数据结构

1. deque的中控器

中控器保存着一组指针，每个指针指向一段数据空间的起始位置，通过中控器可以找到所有的数据空间。如果中控器的数据满了，会重新申请一块更大的空间，并将中控器的所有指针拷贝到新空间中。

2. deque的迭代器

deque的迭代器由四个属性组成

		* node：指向要访问元素的入口地址
		* first，last规定了访问本区间元素的边界条件，而cur则指向实际要访问的元素

# queue

1. 队列是一种容器适配器，专门用于在先进先出中操作，其中从容器一端插入元素，另一端提取元素
2. 队列作为容器适配器实现，**容器适配器即将特定容器类封装作为其底层容器类**，queue提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列
3. 底层容器可以是标准容器类模板之一，也可以是其他专门设计的容器类
4. 标准容器类deque和list满足了这些要求。

# sizeof和strlen

* sizeof是运算符，strlen是函数
* sizeof可以用类型或结构变量做参数,strlen只能用char*做参数且必须是以\0结尾的
* sizeof是在编译阶段确定的，strlen在运行阶段确定

# 算法
用来处理群集内的元素。它们可以出于不同的目的而搜寻、排序、修改、使用那些元素。通过迭代器的协助，我们可以只需编写一次算法，就可以将它应用于任意容器，这是因为所有的容器迭代器都提供一致的接口。
## 迭代器

* 概念：迭代器相当于一个广义指针，通过它来操纵容器中的元素。模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。每个容器类都定义了相应的迭代器类型，他们的实现可能不同，但它们具有一些共同的特征

    1. 都能够对迭代器执行解除引用操作，以便能够访问它引用的值；
    2. 能够将一个迭代器赋给另一个迭代器；
    3. 能够将一个迭代器与另一个迭代器比较，看他们是否相等；
    4. 能够使用迭代器遍历容器中的所有元素。
* 迭代器类型
    1. 输入迭代器
    2. 输出迭代器
    3. 正向迭代器
    4. 双向迭代器
    5. 随机访问迭代器
* 原因
编写算法时尽可能使用要求最低的迭代器，并让他适用于容器的最大区间
# 适配器
为已有的类提供新的接口
* 三种类型适配器
容器适配器：用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器迭代器适配器（反向迭代器、插入迭代器、IO流迭代器）函数适配器（函数对象适配器、成员函数适配器、普通函数适配器）
* 函数对象
一个行为类似函数的对象，它可以没有参数，也可以带有若干参数。
* 分配器
负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class

# hashmap底层实现 扩容机制。hash冲突的解决。
## 概念
**哈希表也叫散列表**，是根据键而直接访问内存存储位置的数据结构，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表，也就是哈希表。
常用的哈希函数有6种：
* 直接定址法
取关键字或关键字的某个线性函数值为散列地址
* 数字分析法
可取关键字的若干数位组成哈希地址
* 平方取中法
取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。
* 折叠法
将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址
* 除数留余法
取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。
* 随机数法
## 哈希冲突
对不同的关键字可能得到同一散列地址
1. **开放定址法**

从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。
在开放定址法中解决冲突的方法有：**线行探查法、平方探查法、双散列函数探查法**。
开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。
    **1.1 线性探查法**           
从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止  
    **1.2 平方探查法**
平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。
在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。
    **1.3 双散列函数探查法**
当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长
2. **拉链法**
**让哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中**，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

* **优点：**
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
**缺点：**
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。
3. **再哈希法**
当通过哈希函数求得的哈希地址同其他关键字产生冲突时，**使用另一个哈希函数计算，直到冲突不再发生。**
2.4 建立公共溢出区
将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区

*  装载因子：
表中已经存入的数据元素个数n 与hash表地址空间大小m的比值

# unordered_map 与 map
**unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符**
**map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。**

# STL中vector的实现
STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。
# vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。
# C++中vector和list的区别
vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“<”等操作符。list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“<”等vector::iterator和list::iterator都重载了“++”运算符。总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;如果需要大量的插入和删除，而不关心随机存取，则应使用list。
# C++中的重载和重写的区别：

* 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
* 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。

# 重载、重写、隐藏

* 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
* 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
* 重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。

# 基类的析构函数一般写成虚函数的原因

**首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。**

# 构造函数为什么一般不定义为虚函数

* 因为创建一个对象时需要确定对象的类型，而**虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类**等等
* 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
# 构造函数或者析构函数中调用虚函数会怎样
**在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式**。
**在析构函数中调用虚函数，此时调用的是子类的函数实现方式。**

# 静态绑定和动态绑定的介绍
静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。
动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。

# 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）
浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。
而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。
深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。
# 介绍C++所有的构造函数

* 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数
* 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。
* 拷贝构造函数是在发生对象复制的时候调用的
# 什么情况下会调用拷贝构造函数（三种情况）

* 对象以值传递的方式传入函数参数
* 对象以值传递的方式从函数返回
* 对象需要通过另外一个对象进行初始化

#  结构体内存对齐方式和为什么要进行内存对齐？
因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。
对齐规则：

* 第一个成员在与结构体变量偏移量为0的地址
* 其他成员变量要对齐到对齐数的整数倍的地址处
* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值
* 整体大小应该事最大成员变量大小的整数倍处
* linux 中默认为4
* vs 中的默认值为8

### 原因

1. **平台原因(移植原因)**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. **性能原因**：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

# 内存泄露的定义，如何检测与避免
动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏

* 造成内存泄漏的几种原因
    1. 类的构造函数和析构函数中new和delete没有配套
    2. 在释放对象数组时没有使用delete[]，使用了delete
    3. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露
*  避免方法：
    1. 使用智能指针
    2. 将基类的析构函数设为虚函数  
# set，map和vector的插入复杂度

* set,map的插入复杂度就是红黑树的插入复杂度，是log(N)
* unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)
* vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝
#  inline关键字说一下 和宏定义有什么区别
inline是内联的意思，可以定义比较小的函数。**因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。**

1. **内联函数在编译时展开，而宏在预编译时展开**
2. **在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换**
3. **内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能**
4. **宏不是函数，而inline是函数**
# c++的智能指针
**智能指针是行为类似于指针的类对象，当它被释放时，会调用析构函数，将它指向的内存一起释放，避免开辟了一块内存，使用完毕后忘记释放，造成内存泄露的情况。(对指针进行赋值，会使得两个指针指向同一块内存，可能存在对同一块内存释放两次的风险)**

* auto_ptr
  在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题

* unique_ptr
  unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针,原指针是临时指针除外

* shared_ptr
  **可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。**（内部使用计数机制进行维护）

* weak_ptr

  shared_ptr是采用引用计数的智能指针，为了避免循环引用引入了weak_ptr,一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数
# c11

* 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作
* nullptr
：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的*
* 新的智能指针 unique_ptr和shared_ptr，weaked_ptr
* 范围for()新的语法格式
* 右值引用
* lambda匿名函数
* thread类和mutex类

# C++的调用惯例（简单一点C++函数调用的压栈过程）

1. 从栈空间分配存储空间
2. 从实参的存储空间复制值到形参栈空间
3. 进行运算
# string的底层实现
string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。
string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。

# 定义和声明的区别

* **声明是告诉编译器变量的类型和名字，不会为变量分配空间** 
* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次
# typdef和define区别
#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名
# 被free回收的内存是立即返还给操作系统吗？为什么
不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
# 友元函数和友元类
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

* 友元函数
有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。
* 友元类
友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
但是另一个类里面也要相应的进行声明
* 注意
    1. 友元关系不能被继承。
    2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
    3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明
# STL中的sort()算法是用什么实现的，stable_sort()呢
STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。
# vector会迭代器失效吗？什么情况下会迭代器失效？

* 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，**first和end迭代器都失效**
* 当vector在插入的时候，**end迭代器肯定会失效**
* 当vector在删除的时候，**被删除元素以及它后面的所有元素迭代器都失效。**
# c++为什么没有实现垃圾回收

* 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作
* 垃圾回收会使得C++不适合进行很多底层的操作

# C/C++中的extern关键字
* 基本解释

C/C++语言中表明**函数和全局变量的作用范围的关键字**，extern可以置于变量或者函数前，以**标示变量或者函数的定义在别的文件中**，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定
两个作用：

1. 当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++
2. 对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，方法有2种：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，方法有2种：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，在头文件中函数可以不用加extern。

* extern与static
  * extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量
  *  **static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面**
  *  不同：
    * extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它，extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它

# inclue 头文件

* include在预处理阶段执行，在源代码被编译之前，替换或添加文本
* **使用原因：**
C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。如果一个b.cpp文件想要调用另一个a.cpp文件中的函数，只需在这个文件中进行一下声明，这编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 "void a()" 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。声明是告诉编译器变量的类型和名字，不会为变量分配空间,定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次.

* 头文件常包含的内容
    * 函数原型
    * 使用#define或const定义的符号常量
    * 结构声明
    * 类声明
    * 模板声明
    * 内联函数

* **避免在一个文件中包含多个头文件，使用条件编译**
#ifndef
#define
#endif
# 静态库和动态库
静态库：即静态链接库。以.a , .lib为文件后缀名。在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库。
动态库：即动态链接库。以.so , .dll 为文件后缀名。在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在
区别：静态库代码装载的速度快，执行速度略比动态库快。但是动态库更加节省内存，可执行文件体积比静态库小很多。静态库是在编译时加载，动态库是在运行时加载。

# 静态连接和动态连接

- **静态链接**：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被**装入**到该进程的虚拟地址空间中。
- **动态链接：**代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

## 静态库的特点
* 装载执行速度快
* 程序编译时链接到代码段中，空间浪费是静态库的一个问题
* 如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户
## 动态库特点
* 节省内存，在运行时加载；
* 可以实现进程之间的资源共享
* 程序升级变得简单

# union

共用体，也叫联合体，在一个“联合”内可以定义多种不同的数据类型,**union变量所占用的内存长度等于最长的成员的内存长度。****union中的所有成员起始地址都是一样的**

# ifndef

头文件中常包含的内容：

* 函数原型

* 使用#define或const定义的符号常量

* 结构声明

* 类声明

* 模板声明

* 内联函数

  作用：在同一个文件中只能将同一个头文件包含一次，避免重复编译导致出错；

# enum

另一种创建符号常量的方式，可以替代;在不进行强制类型转换时，只能将定义枚举时使用的枚举量赋给这种枚举的变量；

# 静态成员函数

* 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）
* 无论有没有创建对象，都可以调用静态成员函数

# 宏定义

* 简单的宏定义
* 带参数的宏定义
* notes：先替换后计算，加（）确定优先级

* 优点：
  * 方便程序的修改
  * 提高程序运行的效率

* define中的三个特殊符号：\# ,\##,\#@
  * \#define Conn(x,y) x\#\#y
    * 表示x连接y
  * \#define ToChar(x) \#@x
    * 表示给x加上单引号
  * \#define ToString(x) \#x
    * 表示给x加上双引号

# 可变参数

* va_list:声明va_list类型的变量，这个变量是指向参数的指针
* va_start：初始化刚定义的va_list变量，使其指向第一个可变参数的地址
* va_arg：返回参数列表中指针arg_ptr所指的参数, 返回类型为type. 并使指针arg_ptr指向参数列表中下一个参数
* va_end：清空参数列表, 并置参数指针arg_ptr无效

# 左值、右值

* **表达式结束后依然存在的持久对象**，可以取地址、有名字的就是左值
* **表达式结束后就不再存在的临时对象**，不能取地址、没有名字的就是右值（将亡值或纯右值）
  * 临时变量
  * 不跟对象关联的字面量值
  * 将亡值
    * 返回右值引用T&&的函数返回值，std::move的返回值

## 左值引用、右值引用

左值引用就是对一个左值进行引用的类型，右值引用是对一个右值类型进行引用。

## 移动构造函数

移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。不会对参数进行复制，而是改变了参数的所有权。

