# 指针和引用
## 概念：
指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原来变量的一个别名。
## 不同：
* 引用不可以为空，当被创建时，必须初始化，而指针可以为空值，可以在任何时候初始化；
* 指针和引用的自增运算意义不一样；
* 指针是一个新变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量本身的操作。
* 指针可以有多级而引用只有一级

ps:const 在类型之前可以修改指针包含的地址，不能修改指针指向的值
const在变量类型之后--可以修改指针指向的值，但不能2修改指针的地址；

# 野指针

**指向不可用内存区域的指针**。如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起崩溃。野指针具有很强的隐蔽性，if语句对它不起作用。

产生原因：

* 指针变量没有被初始化
* 指针指向的内存被释放了，指针本身没有置NULL
* 指针超过了变量的作用范围

## 引用的用处

1. 引用经常用作函数的参数，按引用传递参数可以使用原始数据，**效率更高**
2. 有时候比起使用**指针更加安全**，使用指针经常换的的错误是1.操作空指针。2.操作野指针。3.误操作改变指针的值，使用引用可以便面这些问题，因为不存在空引用，引用必须初始化保证不是野指针，一个引用永远指向他初始化的那个对象。
3. 程序员能**够修改调用函数中的数据对象**；

## 为什么有了引用还需要指针
因为要兼容c语言
## 为什么有了指针还需要引用
**支持运算符重载，使得重载的运算符更符合操作习惯**。

# 多态的实现
## 概念
多态是面向对象程序设计的一个重要特征。多态的字面意思是多种状态，在面向对象语言中，一个接口多种实现为多态。c++中的多态具体体现在编译和运行两个阶段。编译时多态是静态多态，运行时多态为动态多态，具体引用的接口在运行时确定。
## 作用
封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。静态多态，将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。动态多态，则不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。
## c++中实现多态的三种方式

1. 函数重载
2. 模板函数
3. 虚函数
**其中函数重载和模板函数是静态多态，虚函数是动态多态，静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择合适的函数，，动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己该调用哪一类虚函数**。
### 函数重载
允许有不同参数的函数有相同的名字，根据调用时函数的参数列表，选用不同的函数（不将引用和本身作为不同的特征标，同时不区分const常量和非const常量，会尝试使用标准类型转换强制进行匹配）
### 函数模板
#### 概念
函数模板是通用的函数描述，他们使用泛型来定义函数，其中的泛型可用具体的类型（如int或double)替换。
#### 用法
在定义和声明前加 template <typename T>
#### 模板的局限性
编写的模板函数可能无法处理某些类型
#### 显示具体化
无法使用模板重载其他代码，可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，使用该定义，而不在寻找模板
用法：
eg: template<>void Swap<job>(job&,job&)
#### 实例化和具体化
隐式实例化，显示实例化：直接命令编译器生成实例
用法：
template void Swap<int>(int,int)
### 动态多态
动态多态最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而调用不同的方法。如果没有使用虚函数，即没有利用 C++ 多态性，则利用基类指针调用相应函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用同一个函数，这就无法达到“一个接口，多种实现”的目的了
**如果要在派生类中重新定义基类方法，使用虚函数，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果不定义为虚函数，程序将根据引用类型或者指针类型选择方法；如果定义为虚函数，它将根据引用或者指针指向的类型来选择方法。**
动态多态是通过“继承+虚函数”来实现的，只有在程序运行期间（非编译期）才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
**虚析构函数**确保释放派生对象时，按正确顺序调用析构函数。

# 虚函数工作原理
编译器处理虚函数的方法是：为每一个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组成为虚函数表。虚函数表中存储了为类对象声明的虚函数的地址。也就是说基类对象包含有一个指向指针，这个指针指向基类中所有虚函数的地址表，派生类对象有一个指向独立地址表的指针，这个虚函数地址表中中的地址是它重新定义的虚函数的地址。

# 静态联编和动态联编

* 静态
  * 在编译器编译过程中决定使用哪个函数
* 动态
  * 因为虚函数的存在，只能在程序运行中决定使用哪个函数。

# 友元函数
## 作用：
c++控制对类对象私有部分的访问，通常公有类方法提供唯一的访问途径，但这种限制有时候太严格，以至于不适合特定的编程问题。这种情况下，c++提供了另外一种形式的访问权限，友元。
友元有三种：

1. 友元函数；
2. 友元类；
3. 友元成员函数。
## 创建友元函数
一、将其原型放到类声明中，并在原型前面加上关键字friend
二、编写函数定义，因为它不是成员函数，所以不需要使用类限定符。同时不要在定义中使用关键字friend。
## 功能

* 虽然友元函数在类声明中声明，但他不是成员函数，因此不饿能使用成员运算符来调用
* 虽然友元函数不是成员函数，但它与成员函数的访问权限相同

# 构造函数与析构函数

# this指针
# 面向对象的理解
# const static #define

# 类继承
## **三种继承**

1. 公有继承

  **不改变基类成员的访问权限**

2. 保护继承

  **将基类中public成员变为子类的protected成员，其他成员访问权限不变**

3. 私有继承

   **使得基类所有成员在子类中的访问权限变为private**

4. **基类中的private成员不受继承方式的影响，子类永远无权访问**

* 派生类对象具有的特征
1. 派生类对象储存了积累的数据成员（继承了基类的实现）
2. 派生类对象可以使用基类的方法（继承了基类的接口）
* 派生类需要的操作
1. 派生类需要自己的构造函数
 基类对象应该在程序进入派生类对象构造函数之前被创建，使用成员初始化列表来完成这种工作。
2. 派生类可以根据需要添加额外的数据成员和成员函数

* 派生类引用和基类引用的特殊关系
基类指针可以在不进行显示类型转换的情况下指向派生类对象；
基类引用可以在不进行显示类型转换的情况下引用派生对象；
但只能调用基类方法。

## 抽象基类

## 用法：
从两个类中找到他们的共性，放到抽象基类中去；
## 纯虚函数
**当类声明中包含纯虚函数时，不能创建该类的对象，只把包含纯虚函数对象的类用作基类，要成为真正的抽象基类必须包含至少一个纯虚函数。在类中可以不定义该函数。**

* 使用场景
当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数

### 声明
在原型中加=0，使虚函数成为纯虚函数。

# 动态内存分配

# c++的6大组件
## 容器
容器是存放数据的类模板，可变长数组、链表、平衡二叉树等数据结构在STL(标准模板库)中都被实现为容器

* 顺序容器（vector,deque,list）
元素在容器中的位置与元素值无关，即元素不是排序的，将元素插入容器时指定在什么位置插入，元素就位于什么位置。
* 关联容器（set,multiset,map,multimap）
关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。

## vector

特点：

内存可增长的动态数组

数据结构：线性连续内存空间

三个迭代器：一个指向vector容器对象的起始字节位置；一个指向当前当前最后一个元素的末尾字节；还有一个指向整个vector容器占用内存空间的末尾字节。

## deque

一种双向开口的存储空间分段连续的数据结构，每段数据空间内部是连续的，而每段数据空间之间则不一定连续。

### deque与vector的最大差异

1. 允许常数时间内对两端元素进行插入和删除
2. 没有所谓的的容量概念，因为它是以分段连续空间组合而成，随时可以增加一段新空间并连接起来

## 数据结构

1. deque的中控器

中控器保存着一组指针，每个指针指向一段数据空间的起始位置，通过中控器可以找到所有的数据空间。如果中控器的数据满了，会重新申请一块更大的空间，并将中控器的所有指针拷贝到新空间中。

2. deque的迭代器

deque的迭代器由四个属性组成

		* node：指向要访问元素的入口地址
		* first，last规定了访问本区间元素的边界条件，而cur则指向实际要访问的元素

# 算法
用来处理群集内的元素。它们可以出于不同的目的而搜寻、排序、修改、使用那些元素。通过迭代器的协助，我们可以只需编写一次算法，就可以将它应用于任意容器，这是因为所有的容器迭代器都提供一致的接口。
## 迭代器

* 概念：迭代器相当于一个广义指针，通过它来操纵容器中的元素。模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。每个容器类都定义了相应的迭代器类型，他们的实现可能不同，但它们具有一些共同的特征

    1. 都能够对迭代器执行解除引用操作，以便能够访问它引用的值；
    2. 能够将一个迭代器赋给另一个迭代器；
    3. 能够将一个迭代器与另一个迭代器比较，看他们是否相等；
    4. 能够使用迭代器遍历容器中的所有元素。
* 迭代器类型
    1. 输入迭代器
    2. 输出迭代器
    3. 正向迭代器
    4. 双向迭代器
    5. 随机访问迭代器
* 原因
编写算法时尽可能使用要求最低的迭代器，并让他适用于容器的最大区间
# 适配器
为已有的类提供新的接口
* 三种类型适配器
容器适配器：用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器迭代器适配器（反向迭代器、插入迭代器、IO流迭代器）函数适配器（函数对象适配器、成员函数适配器、普通函数适配器）
* 函数对象
一个行为类似函数的对象，它可以没有参数，也可以带有若干参数。
* 分配器
负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class

# hashmap底层实现 扩容机制。hash冲突的解决。
## 概念
**哈希表也叫散列表**，是根据键而直接访问内存存储位置的数据结构，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表，也就是哈希表。
常用的哈希函数有6种：
* 直接定址法
取关键字或关键字的某个线性函数值为散列地址
* 数字分析法
可取关键字的若干数位组成哈希地址
* 平方取中法
取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。
* 折叠法
将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址
* 除数留余法
取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。
* 随机数法
## 哈希冲突
对不同的关键字可能得到同一散列地址
1. **开放定址法**

从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。
在开放定址法中解决冲突的方法有：**线行探查法、平方探查法、双散列函数探查法**。
开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。
    **1.1 线性探查法**           
从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止  
    **1.2 平方探查法**
平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。
在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。
    **1.3 双散列函数探查法**
当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长
2. **拉链法**
**让哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中**，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

* **优点：**
①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
**缺点：**
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。
3. **再哈希法**
当通过哈希函数求得的哈希地址同其他关键字产生冲突时，**使用另一个哈希函数计算，直到冲突不再发生。**
2.4 建立公共溢出区
将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区

*  装载因子：
表中已经存入的数据元素个数n 与hash表地址空间大小m的比值

# unordered_map 与 map
**unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符**
**map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(<)。**

# STL中vector的实现
STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。
# vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。
# C++中vector和list的区别
vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“<”等操作符。list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“<”等vector::iterator和list::iterator都重载了“++”运算符。总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;如果需要大量的插入和删除，而不关心随机存取，则应使用list。
# C++中的重载和重写的区别：

* 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
* 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。
# c++内存管理
在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。
* 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
* 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
* 全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。
* 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。
* **自由存储区**:就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的

# 面向对象的理解
面向对象是对事物的一种抽象，抽象出事物的属性和方法，更有利于程序的扩展维护和重用。面向对象有三大特性：封装，继承和多态。
* 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；
* 继承使得子类可以复用父类的成员和方法，实现了代码重用；
* 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。
# 基类的析构函数一般写成虚函数的原因

**首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。**

# 构造函数为什么一般不定义为虚函数

* 因为创建一个对象时需要确定对象的类型，而**虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类**等等
* 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
# 构造函数或者析构函数中调用虚函数会怎样
**在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式**。
**在析构函数中调用虚函数，此时调用的是子类的函数实现方式。**

# 静态绑定和动态绑定的介绍
静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。
动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。

# 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）
浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。
而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。
深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。
# 介绍C++所有的构造函数

* 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数
* 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。
* 拷贝构造函数是在发生对象复制的时候调用的
# 什么情况下会调用拷贝构造函数（三种情况）

* 对象以值传递的方式传入函数参数
* 对象以值传递的方式从函数返回
* 对象需要通过另外一个对象进行初始化

#  结构体内存对齐方式和为什么要进行内存对齐？
因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。
对齐规则：

* 第一个成员在与结构体变量偏移量为0的地址
* 其他成员变量要对齐到对齐数的整数倍的地址处
* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值
* linux 中默认为4
* vs 中的默认值为8

# 内存泄露的定义，如何检测与避免
动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏

* 造成内存泄漏的几种原因
    1. 类的构造函数和析构函数中new和delete没有配套
    2. 在释放对象数组时没有使用delete[]，使用了delete
    3. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露
*  避免方法：
    1. 使用智能指针
    2. 将基类的析构函数设为虚函数  
# set，map和vector的插入复杂度

* set,map的插入复杂度就是红黑树的插入复杂度，是log(N)
* unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)
* vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝
#  inline关键字说一下 和宏定义有什么区别
inline是内联的意思，可以定义比较小的函数。**因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。**

1. **内联函数在编译时展开，而宏在预编译时展开**
2. **在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换**
3. **内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能**
4. **宏不是函数，而inline是函数**
# c++的智能指针
**智能指针是行为类似于指针的类对象，当它被释放时，会调用析构函数，将它指向的内存一起释放，避免开辟了一块内存，使用完毕后忘记释放，造成内存泄露的情况。(对指针进行赋值，会使得两个指针指向同一块内存，可能存在对同一块内存释放两次的风险)**

* auto_ptr
  在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题

* unique_ptr
  unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针,原指针是临时指针除外

* shared_ptr
  **可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。**（内部使用计数机制进行维护）

* weak_ptr

  shared_ptr是采用引用计数的智能指针，为了避免循环引用引入了weak_ptr,一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数
# c11

* 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作
* nullptr
：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的*
* 新的智能指针 unique_ptr和shared_ptr，weaked_ptr
* 范围for()新的语法格式
* 右值引用
* lambda匿名函数
* thread类和mutex类

# C++继承：共有，私有，保护

1. 公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。
2. 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问
3. 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的

# C++的调用惯例（简单一点C++函数调用的压栈过程）

1. 从栈空间分配存储空间
2. 从实参的存储空间复制值到形参栈空间
3. 进行运算
# string的底层实现
string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。
string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。

# 定义和声明的区别

* **声明是告诉编译器变量的类型和名字，不会为变量分配空间** 
* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次
# typdef和define区别
#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名
# 被free回收的内存是立即返还给操作系统吗？为什么
不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。
# 友元函数和友元类
友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

* 友元函数
有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。
* 友元类
友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
但是另一个类里面也要相应的进行声明
* 注意
    1. 友元关系不能被继承。
    2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
    3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明
# STL中的sort()算法是用什么实现的，stable_sort()呢
STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。
# vector会迭代器失效吗？什么情况下会迭代器失效？

* 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效
* 当vector在插入的时候，end迭代器肯定会失效
* 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。
# c++为什么没有实现垃圾回收

* 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作
* 垃圾回收会使得C++不适合进行很多底层的操作

# C/C++中的extern关键字
* 基本解释

C/C++语言中表明**函数和全局变量的作用范围的关键字**，extern可以置于变量或者函数前，以**标示变量或者函数的定义在别的文件中**，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定
两个作用：

1. 当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++
2. 对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，方法有2种：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，方法有2种：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，在头文件中函数可以不用加extern。

* extern与static
  * extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量
  *  **static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面**
  *  不同：
    * extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它，extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它

# inclue 头文件

* include在预处理阶段执行，在源代码被编译之前，替换或添加文本
* **使用原因：**
C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。如果一个b.cpp文件想要调用另一个a.cpp文件中的函数，只需在这个文件中进行一下声明，这编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 "void a()" 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。声明是告诉编译器变量的类型和名字，不会为变量分配空间,定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次.

* 头文件常包含的内容
    * 函数原型
    * 使用#define或const定义的符号常量
    * 结构声明
    * 类声明
    * 模板声明
    * 内联函数

* 避免在一个文件中包含多个头文件，使用条件编译
#ifndef
#define
#endif
# 静态库和动态库
静态库：即静态链接库。以.a , .lib为文件后缀名。在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库。
动态库：即动态链接库。以.so , .dll 为文件后缀名。在程序编译时并不会被链接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在
区别：静态库代码装载的速度快，执行速度略比动态库快。但是动态库更加节省内存，可执行文件体积比静态库小很多。静态库是在编译时加载，动态库是在运行时加载。

# 静态连接和动态连接

- **静态链接**：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被**装入**到该进程的虚拟地址空间中。
- **动态链接：**代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

## 静态库的特点
* 装载执行速度快
* 程序编译时链接到代码段中，空间浪费是静态库的一个问题
* 如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户
## 动态库特点
* 节省内存，在运行时加载；
* 可以实现进程之间的资源共享
* 程序升级变得简单

# union

共用体，也叫联合体，在一个“联合”内可以定义多种不同的数据类型,**union变量所占用的内存长度等于最长的成员的内存长度。****union中的所有成员起始地址都是一样的**

# ifndef

头文件中常包含的内容：

* 函数原型

* 使用#define或const定义的符号常量

* 结构声明

* 类声明

* 模板声明

* 内联函数

  作用：在同一个文件中只能将同一个头文件包含一次，避免重复编译导致出错；

# enum

另一种创建符号常量的方式，可以替代;在不进行强制类型转换时，只能将定义枚举时使用的枚举量赋给这种枚举的变量；

# tatic用法和意义

static的意思是静态的，可以用来修饰变量，函数和类成员。

- 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。
- 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。
- 类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。

# 作用域为类的常量

* 在类中声明一个枚举
* static const ~

# 静态成员函数

* 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）
* 无论有没有创建对象，都可以调用静态成员函数



# 宏定义

* 简单的宏定义
* 带参数的宏定义
* notes：先替换后计算，加（）确定优先级

* 优点：
  * 方便程序的修改
  * 提高程序运行的效率

* define中的三个特殊符号：\# ,\##,\#@
  * \#define Conn(x,y) x\#\#y
    * 表示x连接y
  * \#define ToChar(x) \#@x
    * 表示给x加上单引号
  * \#define ToString(x) \#x
    * 表示给x加上双引号

# 可变参数

* va_list:声明va_list类型的变量，这个变量是指向参数的指针
* va_start：初始化刚定义的va_list变量，使其指向第一个可变参数的地址
* va_arg：返回参数列表中指针arg_ptr所指的参数, 返回类型为type. 并使指针arg_ptr指向参数列表中下一个参数
* va_end：清空参数列表, 并置参数指针arg_ptr无效



# 对面向对象的理解

面向过程首先考虑的是要遵循的步骤，然后考虑如何表示这些数据；面向对象首先考虑的是数据，不仅要考虑如何表示数据，还要考虑如何使用数据；如先设定室友变量，成员函数。

面向对象有三大特性:

* 继承
  * 通过子类继承了父类的方法和属性，实现了代码重用。
* 封装
  * 封装隐藏了实现细节，使得代码模块化。
* 多态
  * 一个接口，多个实现
  =======
# 左值、右值

* 表达式结束后依然存在的持久对象，可以取地址、有名字的就是左值
* 表达式结束后就不再存在的临时对象，不能取地址、没有名字的就是右值（将亡值或纯右值）
  * 临时变量
  * 不跟对象关联的字面量值
  * 将亡值
    * 返回右值引用T&&的函数返回值，std::move的返回值

## 左值引用、右值引用

左值引用就是对一个左值进行引用的类型，右值引用是对一个右值类型进行引用。

## 移动构造函数

移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。不会对参数进行复制，而是改变了参数的所有权。

