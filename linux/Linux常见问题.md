# 零拷贝

在两个文件描述符之间直接传递数据，从而避免了内核缓冲区和用户缓冲区之间的的数据拷贝，称为零拷贝

sendfile()

splice（）

# 用户缓冲区、内核缓冲区

## 用户缓冲区

* 一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffe
* 作用：`减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间`。

## 内核缓冲区

当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务

等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程

* read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。

## socket缓冲区

* 当某个应用进程调用套接字的write方法时，会先将数据写入该应用进程的缓冲区，此后内核会从该应用进程的缓冲区复制所有数据到要写的套接字的发送缓冲区

* 如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据）， 该应用进程则无法继续写入自身的缓冲区，此时将会被阻塞住。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区
* 如果调用TCP套接字的write方法并成功返回时，仅仅能代表我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据，数据可能还在TCP的发送缓冲区中



# socket可读可写情况

* 可读
  * 内核接收缓冲区中的字节数大于或等于其低水位标记
  * socket通信的对方关闭连接，此时对该socket的读操作将返回0
  * 监听socket上有新的连接请求
  * socket上有未处理的错误
* 可写
  * 发送缓存区可用字节数大于或等于其低水位标记
  * socket的写操作被关闭
  * socket使用非阻塞connect连接成功或者失败（超时）之后
  * socket上有未处理的错误