# 管道

 1. 管道的概念：

    * 本质
      * 内核缓冲区
      * 伪文件：不占用磁盘空间
    * 特点：
      * 两部分
        * 读端，写端，对应两个文件描述符
        * 数据写端流入，读端流出
      * 操作管道的进程被销毁后，管道自动释放
      * 管道默认是阻塞的
        * 读写

	2. 管道的原理

    * 内部实现方式：队列
      * 环形队列
      * 特点:先进先出
    * 缓冲区大小：
      * 默认4k
      * 大小会根据实际情况做适当调整

	3. 管道的局限性

    * 队列：
      * 数据只能读取一次，不能重复读取
    * 半双工
    * 匿名管道
      * 只使用于有血缘关系的进程

	4. 创建匿名管道

    * int pipe(int fd[2])
      * fd  传出参数
      * fd[0] 读端，fd[1] 写端

	5. 父子进程使用管道通信

    * 单个进程可以使用管道完成读写操作

    * 父子进程不需要使用sleep函数

    * 注意事项

      * **父进程读**

        **-- 关闭写端**

      * **子进程写**

        **-- 关闭读端**

6. 管道的读写行为
   * 读操作
     * 有数据
       * read(fd) - 正常读，返回读出的字节数
     * 无数据
       * 写端全部关闭
         * read解除阻塞，返回0
         * 相当于读文件读到了尾部
       * 没有全部关闭
         * read阻塞
   * 写操作
     * 读端全部关闭
       * 管道破裂，进程被终止
         * 内核给当前进程发信号SIGPIPE
     * 读端没全部关闭
       * 缓存区写满了
         * write阻塞
       * 缓存区没有写满
         * write继续写
7. 查看管道缓冲区大小
   * 命令
     * ulimit -a
   * 函数
     * fpathconf
8. 如何设置非阻塞？
   * 默认读写两端都阻塞
   * 使用fcntl

# fifo

1.  特点
   * 有名管道
   * 在磁盘上有这样一个文件 ls -l ->p
   * 伪文件，在磁盘大小永远为0
   * 在内核中有一个对应的缓冲区
   * 半双工的通信方式
2. 使用场景
   
* 没有血缘关系的进程间通信
  
3. 创建方式

   * 命令：mkfifo 管道名
   * 函数：mkfifo

4. fifo文件可以使用IO函数进行操作

   * open/close
   * read/write
   * 不能执行lseek操作

5. 进程间通信

   a. fifo文件 -- myfifo

   * 两个不相干的进程A(a,c) B(b,c)
   * a.c --->read
     * int fd = open("myfifo",O_RDONLY)
     * read(fd,buf,sizeof(buf));
     * close(fd);
   * b.c ---> write
     * int fd1 = open("myfifo",O_WRONLY);
     * write(fd1,"hello,world",11);
     * close(fd1);

# 内存映射区

## mmap 创建内存映射

* 作用：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件

* 函数原型：

  void *mmap(

  void *addr,		//映射区首地址，传NULL

  size_t length,		//映射区的大小

  	* 实际分配的是4k的倍数
  	* 不能为0
  	* 一般文件多大，length就指定多大

  int prot,	            //映射区权限

  ​	PROT_READ -- 映射区必须要有读权限

  ​	PROT_WRITE

  ​	PROT_READ | PROT_WRITE)

  int flags,				//标志位参数

   * MAP_SHARED
     	* 修改了内存数据会同步到磁盘
   * MAP_PRIVATE
      * 修改了内存数据不会同步到磁盘

  int fd,                     //文件描述符

  		* 要映射的文件对应fd

  * off_t offset           //映射文件的偏移量

      * 映射的时候文件指针的偏移量
        		* 必须是4K的整数倍
          		* 0

  * 返回值

    		* 映射区的首地址
    		* MAP_FAILED(void(*)-1)

## munmap  释放内存映射区

* 函数原型：int munmap(void * addr,size_t length)
  * addr  --mmap返回值，映射区的首地址
  * length --mmap的第二个参数，映射区的长度

## 创建匿名映射区

* mmap的时候：
  * 第二个参数：指定映射区大小
  * 第四个参数：需要添加MAP_ANON宏
  * 第五个参数：-1

# 父子进程永远共享的东西

* 文件描述符
* 内存映射区

# 进程间通信

1. 有血缘关系的

   * 父子进程共享内存映射区

2. 没有血缘关系的进程间通信

   * 如何通信

     * 不能使用匿名映射的方式
     * 只能借助磁盘文件创建映射区

   * a(a.c) b(b.c)

     * a.c

       int fd = open("hello")

       void* ptr = mmap(, , , , ,fd,0)

       对映射区进行读写操作

       * ptr

     * b.c

       int fd1 = open("hello");

       void* ptr1 = mmap(, , , , ,fd1,0);

       对映射区进行读写操作

       * ptr1

       