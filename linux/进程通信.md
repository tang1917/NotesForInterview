# 管道

 1. 管道的概念：

    * 本质
      * 内核缓冲区
      * 伪文件：不占用磁盘空间
    * 特点：
      * 两部分
        * 读端，写端，对应两个文件描述符
        * 数据写端流入，读端流出
      * 操作管道的进程被销毁后，管道自动释放
      * 管道默认是阻塞的
        * 读写

	2. 管道的原理

    * 内部实现方式：队列
      * 环形队列
      * 特点:先进先出
    * 缓冲区大小：
      * 默认4k
      * 大小会根据实际情况做适当调整

	3. 管道的局限性

    * 队列：
      * 数据只能读取一次，不能重复读取
    * 半双工
    * 匿名管道
      * 只使用于有血缘关系的进程

	4. 创建匿名管道

    * int pipe(int fd[2])
      * fd  传出参数
      * fd[0] 读端，fd[1] 写端

	5. 父子进程使用管道通信

    * 单个进程可以使用管道完成读写操作

    * 父子进程不需要使用sleep函数

    * 注意事项

      * **父进程读**

        **-- 关闭写端**

      * **子进程写**

        **-- 关闭读端**

6. 管道的读写行为
   * 读操作
     * 有数据
       * read(fd) - 正常读，返回读出的字节数
     * 无数据
       * 写端全部关闭
         * read解除阻塞，返回0
         * 相当于读文件读到了尾部
       * 没有全部关闭
         * read阻塞
   * 写操作
     * 读端全部关闭
       * 管道破裂，进程被终止
         * 内核给当前进程发信号SIGPIPE
     * 读端没全部关闭
       * 缓存区写满了
         * write阻塞
       * 缓存区没有写满
         * write继续写
7. 查看管道缓冲区大小
   * 命令
     * ulimit -a
   * 函数
     * fpathconf
8. 如何设置非阻塞？
   * 默认读写两端都阻塞
   * 使用fcntl

# fifo

1.  特点
   * 有名管道
   * 在磁盘上有这样一个文件 ls -l ->p
   * 伪文件，在磁盘大小永远为0
   * 在内核中有一个对应的缓冲区
   * 半双工的通信方式
2. 使用场景
   * 没有血缘关系的进程间通信

3. 创建方式
   * 命令：mkfifo 管道名
   * 函数：mkfifo