# 进程和程序

# 并行和并发

# pcb

是一个task_struct结构体,其内部成员有很多，如

* 进程id
* 进程的状态
* 进程切换时需要保存和恢复的一些cpu寄存器
* 描述虚拟地址空间的信息等。
* umask掩码
* 文件描述符表
* 当前工作目录
* 和信号相关的信息
* 用户id和组id
* 会话和进程组

# 进程的五种状态

1. 初始态
2. 就绪态
3. 运行态
4. 挂起态
5. 终止态

# 进程控制

1. fork

   int fork(void)

   * **作用：**父进程产生一个子进程，可以理解为子进程是父进程的拷贝，除了进程ID不一样外其他都一样。
   * **返回值：**两个，父进程返回子进程的ID，子进程返回0；**原因：**不同的进程各返回一个

   * getpid/getppid
     * getpid 得到当前进程的PID
     * getppid得到当前进程的父进程的PID
   * 字进程创建成功后，代码的执行位置
     * **父进程执行到了哪，子进程就从哪开始执行**
   * 父子进程的执行顺序
     * 不一定

# 进程相关的命令

* ps
  * ps aux | grep "xxx"
  * ps ajx | grep "xxx"
* kill 向指定的进程发送信号
  * 查看信号: kill -l
  * 杀死某个进程：kill -9(SIGKILL) PID

# 父子进程信息机制

* 读时共享，写时复制
* 父子进程之间不能够用全局变量通信。

# exec函数族

* 让父子进程执行不相干的操作

* 能够替换进程地址空间中的源代码.txt段

* 当前程序中调用另外一个应用程序

  * 首先想到exec之前需要fork

* execl函数

  * int execl(const char* path,const char *arg，.....)；
    * path:要执行程序的绝对路径
    * 变参arg:要执行的程序的需要的参数
    * 第一arg:占位
    * 后边的arg：命令的参数
    * 参数写完之后：NULL
    * 一般执行自己写的程序

* execlp函数

  * **执行PATH环境变量能够搜索到的程序**

  * int execlp(const char* file,const char *arg，.....)；
    * file:要执行的命令的名字
    * 变参arg:要执行的程序的需要的参数
    * 第一arg:占位
    * 后边的arg：命令的参数
    * 参数写完之后：NULL
    * 执行系统自带的程序

# 进程回收

1. 孤儿进程、僵尸进程

2. wait 阻塞函数

   * pid_t wait(int * status);
     * 返回值：
       * -1：回收失败，已经没有子进程了 
       * 大于0回收是子进程对应的pid
     * 参数：status
       * 判断子进程是如何死的
         * 正常退出
         * 被某个信号杀死了
     * 调用一次只能回收一个子进程

3. pid_t waitpid(pid_t pid,int *status,int options)

   * **函数作用：回收子进程**
   * 参数：
     * pid:
       * pid == -1等待任一子进程，与wait等效
       * pid>0 等待其进程ID与pid相等的子进程
       * pid== 0等待其组ID等于调用进程的组ID的任一子进程
       * pid<-1等待其组ID等于pid绝对值的任一子进程
     * status:子进程的退出状态，用法同wait函数
     * options:设置为WNOHANG，函数非阻塞，设置为0，函数阻塞
   * 返回值：
     * 大于0：返回清理掉子进程ID
     * -1：无子进程
     * =0 参3为WNOHANG,且子进程正在运行

   

   

